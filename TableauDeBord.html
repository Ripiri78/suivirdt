<!DOCTYPE html>
<html lang="fr">
<head>
  <base target="_top">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Tableau de Bord Rendement</title>
  
  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  
  <!-- Font Awesome -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>
  
  <style>
    :root {
      --primary: #4361ee;
      --primary-light: #e9efff;
      --secondary: #3f37c9;
      --success: #4cc9f0;
      --warning: #f72585;
      --light-gray: #f8f9fa;
      --text-dark: #2b2d42;
      --text-light: #8d99ae;
      --card-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
      --transition: all 0.3s ease;
      --border-radius: 12px;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background-color: #f5f7ff;
      color: var(--text-dark);
      line-height: 1.6;
      overflow-x: hidden;
    }
    
    .navbar {
      background-color: white;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.05);
    }
    
    .navbar-brand {
      font-weight: 700;
      color: var(--primary);
    }
    
    .card {
      border: none;
      border-radius: var(--border-radius);
      box-shadow: var(--card-shadow);
      transition: var(--transition);
      overflow: hidden;
      margin-bottom: 24px;
    }
    
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }
    
    .card-header {
      background-color: white;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      padding: 16px 20px;
      font-weight: 600;
    }
    
    .card-body {
      padding: 20px;
    }
    
    .btn-primary {
      background-color: var(--primary);
      border-color: var(--primary);
    }
    
    .btn-primary:hover {
      background-color: var(--secondary);
      border-color: var(--secondary);
    }
    
    .btn-outline-primary {
      color: var(--primary);
      border-color: var(--primary);
    }
    
    .btn-outline-primary:hover {
      background-color: var(--primary);
      color: white;
    }
    
    .nav-item .nav-link {
      color: var(--text-dark);
      font-weight: 500;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 5px;
    }
    
    .nav-item .nav-link:hover {
      background-color: var(--primary-light);
    }
    
    .nav-item .nav-link.active {
      background-color: var(--primary);
      color: white;
    }
    
    .nav-item .nav-link i {
      margin-right: 10px;
    }
    
    .stat-card {
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--card-shadow);
      padding: 24px;
      text-align: center;
      height: 100%;
      transition: var(--transition);
    }
    
    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
    }
    
    .stat-card .icon {
      font-size: 26px;
      margin-bottom: 15px;
      color: var(--primary);
    }
    
    .stat-card .value {
      font-size: 28px;
      font-weight: 700;
      margin: 0;
      color: var(--primary);
    }
    
    .stat-card .label {
      font-size: 14px;
      color: var(--text-light);
      margin-top: 5px;
    }
    
    .chart-container {
      position: relative;
      margin: auto;
      height: 300px;
      width: 100%;
    }
    
    .table th {
      font-weight: 600;
      color: var(--text-dark);
      border-top: none;
      background-color: var(--light-gray);
    }
    
    .table td {
      vertical-align: middle;
    }
    
    .badge {
      font-weight: 500;
      padding: 6px 12px;
      border-radius: 50px;
    }
    
    .badge-success {
      background-color: #d9f5ef;
      color: #0cad7a;
    }
    
    .badge-warning {
      background-color: #fff1d6;
      color: #f9a825;
    }
    
    .badge-danger {
      background-color: #ffeaef;
      color: #f72585;
    }
    
    .filter-card {
      background-color: white;
      border-radius: var(--border-radius);
      box-shadow: var(--card-shadow);
      padding: 20px;
      margin-bottom: 24px;
    }
    
    .filter-badge {
      background-color: var(--primary-light);
      color: var(--primary);
      font-weight: 500;
      padding: 8px 16px;
      border-radius: 50px;
      margin-right: 10px;
      margin-bottom: 10px;
      display: inline-flex;
      align-items: center;
    }
    
    .filter-badge .close {
      margin-left: 10px;
      font-size: 16px;
      cursor: pointer;
    }
    
    .loader {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      height: 400px;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(67, 97, 238, 0.2);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .card, .stat-card {
        margin-bottom: 15px;
      }
      
      .navbar-brand {
        font-size: 18px;
      }
      
      .stat-card .value {
        font-size: 22px;
      }
    }
    
    @media (prefers-color-scheme: dark) {
      body {
        background-color: #121212;
        color: #e0e0e0;
      }
      
      .navbar, .card, .card-header, .stat-card {
        background-color: #1e1e1e;
        color: #e0e0e0;
      }
      
      .card-header {
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .table th {
        background-color: #2d2d2d;
        color: #e0e0e0;
      }
      
      .table td {
        color: #e0e0e0;
      }
      
      .table, .table th, .table td {
        border-color: rgba(255, 255, 255, 0.1);
      }
      
      .filter-card {
        background-color: #1e1e1e;
      }
      
      .badge-success {
        background-color: rgba(12, 173, 122, 0.2);
      }
      
      .badge-warning {
        background-color: rgba(249, 168, 37, 0.2);
      }
      
      .badge-danger {
        background-color: rgba(247, 37, 133, 0.2);
      }
    }
  </style>
</head>

<body>

  <!-- Barre de navigation avec bouton pour tous les aléas -->
<nav class="navbar navbar-expand-lg navbar-light">
  <div class="container-fluid">
    <a class="navbar-brand" href="#">
      <i class="fas fa-chart-line me-2"></i>
      Tableau de Bord Rendement
    </a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarNav">
      <ul class="navbar-nav ms-auto">
        <li class="nav-item me-2">
          <button class="btn btn-outline-info" id="btn-view-all-aleas">
            <i class="fas fa-clipboard-list me-2"></i>
            Tous les aléas
          </button>
        </li>
        <li class="nav-item">
          <button class="btn btn-outline-primary" id="btn-toggle-filters">
            <i class="fas fa-filter me-2"></i>
            Filtres
          </button>
        </li>
      </ul>
    </div>
  </div>
</nav>

  <!-- Section des filtres (masquée par défaut) -->
  <div class="container-fluid py-3" id="filters-container" style="display: none; background-color: var(--primary-light);">
    <div class="container">
      <div class="filter-card">
        <h5 class="mb-3">
          <i class="fas fa-filter me-2"></i>
          Filtres
        </h5>
        <div class="row">
          <!-- Filtre de dates -->
          <div class="col-md-6 mb-3">
            <label class="form-label">Période</label>
            <div class="input-group">
              <span class="input-group-text"><i class="fas fa-calendar"></i></span>
              <input type="date" class="form-control" id="date-debut" placeholder="Date de début">
              <span class="input-group-text">à</span>
              <input type="date" class="form-control" id="date-fin" placeholder="Date de fin">
            </div>
          </div>
          
          <!-- Filtre de rendement -->
          <div class="col-md-6 mb-3">
            <label class="form-label">Rendement</label>
            <div class="row">
              <div class="col-6">
                <div class="input-group">
                  <span class="input-group-text">Min</span>
                  <input type="number" class="form-control" id="rendement-min" min="0" max="1" step="0.01" placeholder="0">
                </div>
              </div>
              <div class="col-6">
                <div class="input-group">
                  <span class="input-group-text">Max</span>
                  <input type="number" class="form-control" id="rendement-max" min="0" max="1" step="0.01" placeholder="1">
                </div>
              </div>
            </div>
          </div>
          
          <!-- Filtre d'équipe -->
          <div class="col-md-6 mb-3">
            <label class="form-label">Équipe</label>
            <div class="input-group">
              <span class="input-group-text"><i class="fas fa-users"></i></span>
              <select class="form-select" id="equipe-select">
                <option value="">Toutes les équipes</option>
                <!-- Rempli dynamiquement -->
              </select>
            </div>
          </div>
          
          <!-- Filtre de poste -->
          <div class="col-md-6 mb-3">
            <label class="form-label">Poste</label>
            <div class="input-group">
              <span class="input-group-text"><i class="fas fa-briefcase"></i></span>
              <select class="form-select" id="poste-select">
                <option value="">Tous les postes</option>
                <!-- Rempli dynamiquement -->
              </select>
            </div>
          </div>
        </div>
        
        <div class="d-flex justify-content-end mt-3">
          <button class="btn btn-light me-2" id="btn-reset-filters">
            <i class="fas fa-undo me-1"></i> Réinitialiser
          </button>
          <button class="btn btn-primary" id="btn-apply-filters">
            <i class="fas fa-check me-1"></i> Appliquer
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Section des filtres actifs -->
  <div class="container-fluid py-2" id="active-filters" style="display: none; background-color: white;">
    <div class="container">
      <div class="d-flex flex-wrap align-items-center">
        <h6 class="mb-0 me-3">Filtres actifs :</h6>
        <div id="filter-badges" class="d-flex flex-wrap"></div>
        <button class="btn btn-sm btn-outline-secondary ms-auto" id="btn-clear-all-filters">
          Effacer tout
        </button>
      </div>
    </div>
  </div>

  <!-- Loader -->
  <div class="container py-4" id="loader">
    <div class="loader">
      <div class="spinner"></div>
      <h4>Chargement des données...</h4>
      <p class="text-muted">Merci de patienter</p>
    </div>
  </div>

  <!-- Contenu principal -->
  <div class="container py-4" id="main-content" style="display: none;">
    <div class="row">
      <!-- Menu latéral -->
      <div class="col-md-3 mb-4">
        <div class="card">
          <div class="card-header">
            <i class="fas fa-compass me-2"></i>
            Navigation
          </div>
          <div class="card-body p-0">
            <div class="nav flex-column nav-pills p-3" id="v-pills-tab" role="tablist">
              <a class="nav-link active" id="tab-overview" data-bs-toggle="pill" href="#overview" role="tab">
                <i class="fas fa-home"></i> Vue d'ensemble
              </a>
              <a class="nav-link" id="tab-postes" data-bs-toggle="pill" href="#postes" role="tab">
                <i class="fas fa-briefcase"></i> Par Poste
              </a>
              <a class="nav-link" id="tab-equipes" data-bs-toggle="pill" href="#equipes" role="tab">
                <i class="fas fa-users"></i> Par Équipe
              </a>
              <a class="nav-link" id="tab-evolution" data-bs-toggle="pill" href="#evolution" role="tab">
                <i class="fas fa-chart-line"></i> Évolution
              </a>
              <a class="nav-link" id="tab-operateurs" data-bs-toggle="pill" href="#operateurs" role="tab">
                <i class="fas fa-user-cog"></i> Opérateurs
              </a>
              
<a class="nav-link" id="tab-inactivite" data-bs-toggle="pill" href="#inactivite" role="tab">
  <i class="fas fa-coffee"></i> Inactivité
</a>
              <a class="nav-link" id="tab-aleas" data-bs-toggle="pill" href="#aleas" role="tab">
  <i class="fas fa-exclamation-triangle"></i> Analyse Aléas
</a>
            </div>
          </div>
        </div>
        
        <div class="card mt-4" id="operateur-selector" style="display: none;">
          <div class="card-header">
            <i class="fas fa-user-check me-2"></i>
            Détail Opérateur
          </div>
          <div class="card-body">
            <select class="form-select mb-3" id="operateur-select">
              <option value="">Sélectionner un opérateur</option>
              <!-- Rempli dynamiquement -->
            </select>
            <button class="btn btn-primary w-100" id="btn-load-operateur">
              <i class="fas fa-search me-2"></i>
              Afficher les détails
            </button>
          </div>
        </div>
      </div>
      
      <!-- Contenu des onglets -->
      <div class="col-md-9">
        <!-- Contenu des onglets -->
<div class="tab-content">
  <!-- Vue d'ensemble -->
  <div class="tab-pane fade show active" id="overview" role="tabpanel">
    <!-- Indicateurs de performance -->
    <div class="row mb-4">
      <div class="col-md-4 mb-4 mb-md-0">
        <div class="stat-card">
          <div class="icon">
            <i class="fas fa-percentage"></i>
          </div>
          <h2 class="value" id="rendement-global">--</h2>
          <p class="label">Rendement moyen</p>
        </div>
      </div>
      <div class="col-md-4 mb-4 mb-md-0">
        <div class="stat-card">
          <div class="icon">
            <i class="fas fa-stopwatch"></i>
          </div>
          <h2 class="value" id="tai-global">--</h2>
          <p class="label">TAI moyen</p>
        </div>
      </div>
      <div class="col-md-4">
        <div class="stat-card">
          <div class="icon">
            <i class="fas fa-clock"></i>
          </div>
          <h2 class="value" id="presence-globale">--</h2>
          <p class="label">Présence moyenne (h)</p>
        </div>
      </div>
    </div>
    <!-- Ajouter une nouvelle rangée avec les cartes d'aléas et d'inactivité -->
    <div class="row mb-4">
    <div class="col-md-6 mb-4 mb-md-0">
    <div class="stat-card">
      <div class="icon">
        <i class="fas fa-exclamation-triangle"></i>
      </div>
      <h2 class="value" id="aleas-total-heures">--</h2>
      <p class="label">Total heures d'aléas</p>
    </div>
    </div>
  <div class="col-md-6">
    <div class="stat-card">
      <div class="icon">
        <i class="fas fa-coffee"></i>
      </div>
      <h2 class="value" id="inactivite-total-heures">--</h2>
      <p class="label">Total heures d'inactivité (hors congés)</p>
    </div>
  </div>
</div>

<!-- Graphique de comparaison TAI/Aléas/Inactivité avec objectif interactif -->
<div class="card mb-4">
  <div class="card-header d-flex justify-content-between align-items-center">
    <div>
      <i class="fas fa-chart-bar me-2"></i>
      Comparaison TAI / Aléas / Inactivité (hors congés)
    </div>
    
    <div class="d-flex align-items-center">
      <label for="objectif-valeur" class="me-2 mb-0">Objectif:</label>
      <input type="number" class="form-control form-control-sm" id="objectif-valeur" 
        min="0" step="10" style="width: 100px;" value="100">
      <button class="btn btn-sm btn-primary ms-2" id="btn-apply-objectif">
        <i class="fas fa-check"></i> Appliquer
      </button>
    </div>
  </div>
  <div class="card-body">
    <div class="chart-container">
      <canvas id="chart-comparaison-tai-aleas-inactivite"></canvas>
    </div>
  </div>
</div>

    <!-- Aperçu des performances par poste -->
    <div class="card mb-4">
      <div class="card-header">
        <i class="fas fa-chart-bar me-2"></i>
        Top postes par rendement
      </div>
      <div class="card-body">
        <div class="chart-container">
          <canvas id="chart-top-postes"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Distribution des équipes -->
    <div class="card">
      <div class="card-header">
        <i class="fas fa-users me-2"></i>
        Performance des équipes
      </div>
      <div class="card-body">
        <div class="chart-container">
          <canvas id="chart-equipes-overview"></canvas>
        </div>
      </div>
    </div>
    <div class="card mb-4">
          <div class="card-header">
            <i class="fas fa-stopwatch me-2"></i>
            Somme TAI par poste
          </div>
          <div class="card-body">
            <div class="row mb-3">
              <div class="col-md-3 mb-3 mb-md-0">
                <div class="stat-card">
                  <div class="icon">
                    <i class="fas fa-calculator"></i>
                  </div>
                  <h2 class="value" id="tai-total-global">--</h2>
                  <p class="label">TAI Total Global</p>
                </div>
              </div>
              <div class="col-md-9">
                <div class="table-responsive">
                  <table class="table table-sm table-hover" id="table-tai-postes">
                    <thead>
                      <tr>
                        <th>Poste</th>
                        <th>TAI Total</th>
                        <th>% du Total</th>
                      </tr>
                    </thead>
                    <tbody>
                      <!-- Rempli dynamiquement -->
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
  </div>
  
  <!-- Par Poste -->
  <div class="tab-pane fade" id="postes" role="tabpanel">
    <div class="card">
      <div class="card-header">
        <i class="fas fa-briefcase me-2"></i>
        Analyse par poste
      </div>
      <div class="card-body">
        <div class="chart-container mb-4">
          <canvas id="chart-postes-performance"></canvas>
        </div>
        
        <h5 class="mt-4 mb-3">
          <i class="fas fa-table me-2"></i>
          Détail par poste
        </h5>
        
        <div class="table-responsive">
          <table class="table table-hover" id="table-postes">
            <thead>
              <tr>
                <th>Poste</th>
                <th>Rendement</th>
                <th>TAI</th>
                <th>Présence</th>
                <th>Entrées</th>
                <th>Statut</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rempli dynamiquement -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Par Équipe -->
  <div class="tab-pane fade" id="equipes" role="tabpanel">
    <div class="card">
      <div class="card-header">
        <i class="fas fa-users me-2"></i>
        Analyse par équipe
      </div>
      <div class="card-body">
        <div class="chart-container mb-4">
          <canvas id="chart-equipes-performance"></canvas>
        </div>
        
        <h5 class="mt-4 mb-3">
          <i class="fas fa-table me-2"></i>
          Détail par équipe
        </h5>
        
        <div class="table-responsive">
          <table class="table table-hover" id="table-equipes">
            <thead>
              <tr>
                <th>Équipe</th>
                <th>Rendement</th>
                <th>TAI</th>
                <th>Présence</th>
                <th>Entrées</th>
                <th>Statut</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rempli dynamiquement -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Évolution -->
  <div class="tab-pane fade" id="evolution" role="tabpanel">
    <div class="card">
      <div class="card-header">
        <i class="fas fa-chart-line me-2"></i>
        Évolution du rendement
        <div class="float-end">
          <div class="btn-group btn-group-sm" role="group">
            <input type="radio" class="btn-check" name="periode-type" id="periode-annee" value="annee" checked>
            <label class="btn btn-outline-primary" for="periode-annee">
              Année
            </label>
            <input type="radio" class="btn-check" name="periode-type" id="periode-mois" value="mois">
            <label class="btn btn-outline-primary" for="periode-mois">
              Mois
            </label>
            <input type="radio" class="btn-check" name="periode-type" id="periode-semaine" value="semaine">
            <label class="btn btn-outline-primary" for="periode-semaine">
              Semaine
            </label>
          </div>
        </div>
      </div>
      <div class="card-body">
        <div class="chart-container mb-4">
          <canvas id="chart-evolution"></canvas>
        </div>
        
        <h5 class="mt-4 mb-3">
          <i class="fas fa-table me-2"></i>
          Détail par période
        </h5>
        
        <div class="table-responsive">
          <table class="table table-hover" id="table-evolution">
            <thead>
              <tr>
                <th>Période</th>
                <th>Rendement</th>
                <th>Entrées</th>
                <th>Tendance</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rempli dynamiquement -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Opérateurs -->
  <div class="tab-pane fade" id="operateurs" role="tabpanel">
  <!-- Carte de filtre par poste -->
  <div class="card mb-4" id="poste-filter-card">
    <div class="card-header">
      <i class="fas fa-filter me-2"></i>
      Filtrer par poste
    </div>
    <div class="card-body">
      <div class="btn-group btn-group-sm flex-wrap" role="group" id="poste-filter-buttons">
        <input type="radio" class="btn-check" name="poste-filter" id="poste-filter-all" value="all" checked>
        <label class="btn btn-outline-primary" for="poste-filter-all">
          Tous les postes
        </label>
        <!-- Les autres boutons seront générés dynamiquement -->
      </div>
    </div>
  </div>
  
  <!-- Carte des performances des opérateurs -->
  <div class="card">
    <div class="card-header">
      <i class="fas fa-user-cog me-2"></i>
      Performance
      <div class="float-end">
        <div class="input-group input-group-sm" style="width: 200px;">
          <input type="text" class="form-control" placeholder="Rechercher..." id="operateur-search">
          <button class="btn btn-outline-secondary" type="button" id="btn-clear-search">
            <i class="fas fa-times"></i>
          </button>
        </div>
      </div>
    </div>
    <div class="card-body">
      <div class="chart-container mb-4">
        <canvas id="chart-top-operateurs"></canvas>
      </div>
      
      <h5 class="mt-4 mb-3">
        <i class="fas fa-table me-2"></i>
        Rendement
      </h5>
      
      <div class="table-responsive">
        <table class="table table-hover" id="table-operateurs">
          <thead>
            <tr>
              <th>#</th>
              <th>Opérateur</th>
              <th>Rendement</th>
              <th>TAI</th>
              <th>Présence</th>
              <th>Entrées</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            <!-- Rempli dynamiquement -->
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>
  
  <!-- Détail Opérateur -->
  <div class="tab-pane fade" id="operateur-detail" role="tabpanel">
    <div class="card">
      <div class="card-header">
        <i class="fas fa-user-check me-2"></i>
        Détail de l'opérateur: <span id="operateur-name" class="fw-bold">--</span>
        <button class="btn btn-sm btn-outline-primary float-end" id="btn-back-to-operateurs">
          <i class="fas fa-arrow-left me-1"></i> Retour
        </button>
      </div>
      
      <div class="card-body">
        <!-- Indicateurs de performance -->
        <div class="row mb-4">
          <div class="col-md-4 mb-4 mb-md-0">
            <div class="stat-card">
              <div class="icon">
                <i class="fas fa-percentage"></i>
              </div>
              <h2 class="value" id="operateur-rendement">--</h2>
              <p class="label">Rendement moyen</p>
            </div>
          </div>
          <div class="col-md-4 mb-4 mb-md-0">
            <div class="stat-card">
              <div class="icon">
                <i class="fas fa-stopwatch"></i>
              </div>
              <h2 class="value" id="operateur-tai">--</h2>
              <p class="label">TAI moyen</p>
            </div>
          </div>
          <div class="col-md-4">
            <div class="stat-card">
              <div class="icon">
                <i class="fas fa-clock"></i>
              </div>
              <h2 class="value" id="operateur-presence">--</h2>
              <p class="label">Présence moyenne (h)</p>
            </div>
          </div>
        </div>
        
        
        <!-- Évolution du rendement -->
        <div class="chart-container mb-4">
          <canvas id="chart-operateur-evolution"></canvas>
        </div>
        
        <div class="row">
          <div class="col-md-6 mb-4">
            <h5 class="mb-3">
              <i class="fas fa-briefcase me-2"></i>
              Par poste
            </h5>
            <div class="chart-container">
              <canvas id="chart-operateur-postes"></canvas>
            </div>
          </div>
          <div class="col-md-6 mb-4">
            <h5 class="mb-3">
              <i class="fas fa-users me-2"></i>
              Par équipe
            </h5>
            <div class="chart-container">
              <canvas id="chart-operateur-equipes"></canvas>
            </div>
          </div>
        </div>
        
        <h5 class="mt-2 mb-3">
          <i class="fas fa-table me-2"></i>
          Détail par période
        </h5>
        
        <div class="table-responsive">
          <table class="table table-hover" id="table-operateur-periodes">
            <thead>
              <tr>
                <th>Période</th>
                <th>Rendement</th>
                <th>Entrées</th>
                <th>Statut</th>
              </tr>
            </thead>
            <tbody>
              <!-- Rempli dynamiquement -->
            </tbody>
          </table>
        </div>
        



<!-- Section des aléas de l'opérateur -->
<h5 class="mt-4 mb-3">
  <i class="fas fa-exclamation-triangle me-2"></i>
  Aléas déclarés
</h5>

<div id="operateur-aleas-section">
  <!-- État de chargement -->
  <div id="operateur-aleas-loading" class="text-center py-4">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Chargement...</span>
    </div>
    <p class="mt-2">Chargement des aléas...</p>
  </div>
  
  <!-- Message d'erreur -->
  <div id="operateur-aleas-error" class="alert alert-danger" style="display: none;">
    Une erreur est survenue lors du chargement des aléas.
  </div>
  
  <!-- Message quand aucun aléa n'est trouvé -->
  <div id="operateur-aleas-empty" class="alert alert-info" style="display: none;">
    <i class="fas fa-info-circle me-2"></i>
    Aucun aléa déclaré par cet opérateur dans la période sélectionnée.
  </div>
  
  <!-- Tableau des aléas -->
  <div id="operateur-aleas-content" style="display: none;">
    <div class="mb-3 d-flex justify-content-between align-items-center">
      <div>
        <span class="badge bg-primary" id="operateur-aleas-count">0 aléas</span>
        <small class="text-muted ms-2" id="operateur-aleas-filters-info"></small>
      </div>
      <div>
        <input type="text" class="form-control form-control-sm d-inline-block me-2" id="operateur-aleas-search" placeholder="Rechercher..." style="width: 200px;">
        <button class="btn btn-sm btn-outline-primary" id="btn-export-operateur-aleas">
          <i class="fas fa-file-export me-1"></i> Exporter
        </button>
      </div>
    </div>
    
    <div class="table-responsive">
      <table class="table table-striped table-hover" id="operateur-aleas-table">
        <thead>
          <tr>
            <th>Date</th>
            <th>Type</th>
            <th>Poste</th>
            <th>Équipe</th>
            <th>Durée (h)</th>
            <th>Commentaire</th>
          </tr>
        </thead>
        <tbody id="operateur-aleas-table-body">
          <!-- Rempli dynamiquement -->
        </tbody>
      </table>
    </div>
    
    <!-- Pagination -->
    <div class="d-flex justify-content-between align-items-center mt-3">
      <div>
        <span class="text-muted" id="operateur-aleas-pagination-info">Affichage de 1-10 sur 0</span>
      </div>
      <div id="operateur-aleas-pagination" class="btn-group">
        <button class="btn btn-sm btn-outline-primary" id="operateur-btn-prev-page" disabled>
          <i class="fas fa-chevron-left"></i>
        </button>
        <button class="btn btn-sm btn-outline-primary" id="operateur-btn-next-page" disabled>
          <i class="fas fa-chevron-right"></i>
        </button>
      </div>
    </div>
  </div>
</div>
      </div>
    </div>
  </div>
<!-- Inactivité -->
<div class="tab-pane fade" id="inactivite" role="tabpanel">
  <!-- État de chargement -->
  <div id="inactivite-loading" class="text-center py-4">
    <div class="spinner-border text-primary" role="status">
      <span class="visually-hidden">Chargement...</span>
    </div>
    <p class="mt-2">Chargement des données d'inactivité...</p>
  </div>

  <!-- Message d'erreur -->
  <div id="inactivite-error" class="alert alert-danger" style="display: none;">
    Une erreur est survenue lors du chargement des données d'inactivité.
  </div>

  <!-- Message quand aucune donnée n'est trouvée -->
  <div id="inactivite-empty" class="alert alert-info" style="display: none;">
    <i class="fas fa-info-circle me-2"></i>
    Aucune donnée d'inactivité trouvée pour la période sélectionnée.
  </div>

  <!-- Contenu de l'analyse -->
  <div id="inactivite-content" style="display: none;">
    <!-- Indicateurs des temps d'inactivité -->
    <div class="row mb-4">
      <div class="col-md-3 mb-4 mb-md-0">
        <div class="stat-card">
          <div class="icon">
            <i class="fas fa-clock"></i>
          </div>
          <h2 class="value" id="inactivite-total">--</h2>
          <p class="label">Total heures d'inactivité</p>
        </div>
      </div>
      <div class="col-md-3 mb-4 mb-md-0">
        <div class="stat-card">
          <div class="icon">
            <i class="fas fa-percentage"></i>
          </div>
          <h2 class="value" id="inactivite-pourcentage">--</h2>
          <p class="label">% du temps total</p>
        </div>
      </div>
      <div class="col-md-3 mb-4 mb-md-0">
        <div class="stat-card">
          <div class="icon">
            <i class="fas fa-user-clock"></i>
          </div>
          <h2 class="value" id="inactivite-moyenne-operateur">--</h2>
          <p class="label">Moyenne par opérateur</p>
        </div>
      </div>
      <div class="col-md-3">
        <div class="stat-card">
          <div class="icon">
            <i class="fas fa-users"></i>
          </div>
          <h2 class="value" id="inactivite-moyenne-equipe">--</h2>
          <p class="label">Moyenne par équipe</p>
        </div>
      </div>
    </div>

    <!-- Graphique par type d'inactivité -->
    <div class="card mb-4">
      <div class="card-header d-flex justify-content-between align-items-center">
        <div>
          <i class="fas fa-chart-pie me-2"></i>
          Répartition par type d'inactivité
        </div>
        <button class="btn btn-sm btn-outline-primary" id="btn-refresh-inactivite">
          <i class="fas fa-sync-alt me-1"></i> Actualiser
        </button>
      </div>
      <div class="card-body">
        <div class="chart-container">
          <canvas id="chart-inactivite-types"></canvas>
        </div>
      </div>
    </div>

    <!-- Tableau détaillé des types d'inactivité -->
    <div class="card mb-4">
      <div class="card-header">
        <i class="fas fa-table me-2"></i>
        Détail par type d'inactivité
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-striped table-hover" id="table-inactivite-types">
            <thead>
              <tr>
                <th>Type</th>
                <th>Durée totale (h)</th>
                <th>Pourcentage (%)</th>
                <th>Occurrences</th>
                <th>Durée moyenne (h)</th>
              </tr>
            </thead>
            <tbody id="table-inactivite-types-body">
              <!-- Données générées dynamiquement -->
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Graphiques par poste et par équipe -->
    <div class="row">
      <div class="col-md-6 mb-4">
        <div class="card h-100">
          <div class="card-header">
            <i class="fas fa-briefcase me-2"></i>
            Top postes par durée d'inactivité
          </div>
          <div class="card-body">
            <div class="chart-container">
              <canvas id="chart-inactivite-postes"></canvas>
            </div>
          </div>
        </div>
      </div>
      <div class="col-md-6 mb-4">
        <div class="card h-100">
          <div class="card-header">
            <i class="fas fa-users me-2"></i>
            Top équipes par durée d'inactivité
          </div>
          <div class="card-body">
            <div class="chart-container">
              <canvas id="chart-inactivite-equipes"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Graphique d'évolution temporelle -->
    <div class="card">
      <div class="card-header">
        <i class="fas fa-chart-line me-2"></i>
        Évolution de l'inactivité
        <div class="float-end">
          <div class="btn-group btn-group-sm" role="group">
            <input type="radio" class="btn-check" name="inactivite-periode-type" id="inactivite-periode-mois" value="mois" checked>
            <label class="btn btn-outline-primary" for="inactivite-periode-mois">
              Par mois
            </label>
            <input type="radio" class="btn-check" name="inactivite-periode-type" id="inactivite-periode-semaine" value="semaine">
            <label class="btn btn-outline-primary" for="inactivite-periode-semaine">
              Par semaine
            </label>
          </div>
        </div>
      </div>
      <div class="card-body">
        <div class="chart-container">
          <canvas id="chart-inactivite-evolution"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

  <!-- Analyse Aléas (maintenant au bon niveau) -->
  <div class="tab-pane fade" id="aleas" role="tabpanel">
    <div class="card">
      <div class="card-header">
        <i class="fas fa-exclamation-triangle me-2"></i>
        Analyse des aléas
        <div class="float-end">
          <button class="btn btn-sm btn-outline-primary" id="btn-refresh-aleas-analysis">
            <i class="fas fa-sync-alt me-1"></i> Actualiser
          </button>
        </div>
      </div>
      <div class="card-body">
        <!-- État de chargement -->
        <div id="aleas-analysis-loading" class="text-center py-4">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Chargement...</span>
          </div>
          <p class="mt-2">Chargement des données d'aléas...</p>
        </div>

        <!-- Message d'erreur -->
        <div id="aleas-analysis-error" class="alert alert-danger" style="display: none;">
          Une erreur est survenue lors du chargement des données d'aléas.
        </div>

        <!-- Message quand aucun aléa n'est trouvé -->
        <div id="aleas-analysis-empty" class="alert alert-info" style="display: none;">
          <i class="fas fa-info-circle me-2"></i>
          Aucun aléa trouvé pour la période sélectionnée.
        </div>

        <!-- Contenu de l'analyse -->
        <div id="aleas-analysis-content" style="display: none;">
          <!-- Indicateurs des aléas -->
          <div class="row mb-4">
            <div class="col-md-3 mb-4 mb-md-0">
              <div class="stat-card">
                <div class="icon">
                  <i class="fas fa-exclamation-circle"></i>
                </div>
                <h2 class="value" id="aleas-count-indicator">--</h2>
                <p class="label">Nombre total d'aléas</p>
              </div>
            </div>
            <div class="col-md-3 mb-4 mb-md-0">
              <div class="stat-card">
                <div class="icon">
                  <i class="fas fa-clock"></i>
                </div>
                <h2 class="value" id="aleas-duree-total">--</h2>
                <p class="label">Heures total d'aléas</p>
              </div>
            </div>
            <div class="col-md-3 mb-4 mb-md-0">
              <div class="stat-card">
                <div class="icon">
                  <i class="fas fa-stopwatch"></i>
                </div>
                <h2 class="value" id="aleas-duree-moyenne">--</h2>
                <p class="label">Durée moyenne (h)</p>
              </div>
            </div>
            <div class="col-md-3">
              <div class="stat-card">
                <div class="icon">
                  <i class="fas fa-calendar-alt"></i>
                </div>
                <h2 class="value" id="aleas-impact-percent">--</h2>
                <p class="label">Impact sur production (%)</p>
              </div>
            </div>
          </div>

          <!-- Diagramme Pareto des types d'aléas -->
          <div class="card mb-4">
            <div class="card-header">
              <i class="fas fa-chart-bar me-2"></i>
              Pareto des types d'aléas
            </div>
            <div class="card-body">
              <div class="chart-container">
                <canvas id="chart-aleas-types"></canvas>
              </div>
            </div>
          </div>

          <div class="row">
            <!-- Distribution par poste -->
            <div class="col-md-6 mb-4">
              <div class="card h-100">
                <div class="card-header">
                  <i class="fas fa-briefcase me-2"></i>
                  Répartition des aléas par poste
                </div>
                <div class="card-body">
                  <div class="chart-container">
                    <canvas id="chart-aleas-postes"></canvas>
                  </div>
                </div>
              </div>
            </div>

            <!-- Distribution par équipe -->
            <div class="col-md-6 mb-4">
              <div class="card h-100">
                <div class="card-header">
                  <i class="fas fa-users me-2"></i>
                  Répartition des aléas par équipe
                </div>
                <div class="card-body">
                  <div class="chart-container">
                    <canvas id="chart-aleas-equipes"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Évolution temporelle des aléas -->
          <div class="card mb-4">
            <div class="card-header">
              <i class="fas fa-chart-line me-2"></i>
              Évolution des aléas dans le temps
              <div class="float-end">
                <div class="btn-group btn-group-sm" role="group">
                  <input type="radio" class="btn-check" name="aleas-periode-type" id="aleas-periode-mois" value="mois" checked>
                  <label class="btn btn-outline-primary" for="aleas-periode-mois">
                    Par mois
                  </label>
                  <input type="radio" class="btn-check" name="aleas-periode-type" id="aleas-periode-semaine" value="semaine">
                  <label class="btn btn-outline-primary" for="aleas-periode-semaine">
                    Par semaine
                  </label>
                </div>
              </div>
            </div>
            <div class="card-body">
              <div class="chart-container">
                <canvas id="chart-aleas-evolution"></canvas>
              </div>
            </div>
          </div>

          <!-- Top opérateurs avec le plus d'aléas -->
          <div class="card">
            <div class="card-header">
              <i class="fas fa-user-clock me-2"></i>
              Top opérateurs par nombre d'aléas
            </div>
            <div class="card-body">
              <div class="row">
                <div class="col-md-6">
                  <div class="chart-container">
                    <canvas id="chart-aleas-operateurs-count"></canvas>
                  </div>
                </div>
                <div class="col-md-6">
                  <div class="chart-container">
                    <canvas id="chart-aleas-operateurs-duree"></canvas>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- Ajout du tableau des aléas au bas de l'onglet d'analyse des aléas -->
<!-- À ajouter juste avant la fermeture de la div #aleas-analysis-content -->

<!-- Tableau de tous les aléas -->
<div class="card mt-4">
  <div class="card-header">
    <i class="fas fa-list me-2"></i>
    Liste détaillée des aléas
    <div class="float-end">
      <div class="input-group input-group-sm" style="width: 200px;">
        <input type="text" class="form-control" placeholder="Rechercher..." id="aleas-analysis-search">
        <button class="btn btn-outline-secondary" type="button" id="btn-clear-aleas-search">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
  </div>
  <div class="card-body">
    <div class="mb-3 d-flex justify-content-between align-items-center">
      <div>
        <span class="badge bg-primary" id="aleas-analysis-table-count">0 aléas</span>
        <small class="text-muted ms-2" id="aleas-analysis-table-filters-info"></small>
      </div>
      <button class="btn btn-sm btn-outline-primary" id="btn-export-aleas-analysis">
        <i class="fas fa-file-export me-1"></i> Exporter
      </button>
    </div>
    
    <div class="table-responsive">
      <table class="table table-striped table-hover" id="aleas-analysis-table">
        <thead>
          <tr>
            <th>Date</th>
            <th>Opérateur</th>
            <th>Équipe</th>
            <th>Poste</th>
            <th>Type</th>
            <th>Durée (h)</th>
            <th>Commentaire</th>
          </tr>
        </thead>
        <tbody id="aleas-analysis-table-body">
          <!-- Rempli dynamiquement -->
        </tbody>
      </table>
    </div>
    
    <!-- Pagination -->
    <div class="d-flex justify-content-between align-items-center mt-3">
      <div>
        <span class="text-muted" id="aleas-pagination-info">Affichage de 1-20 sur 0</span>
      </div>
      <div id="aleas-pagination" class="btn-group">
        <button class="btn btn-sm btn-outline-primary" id="btn-prev-page" disabled>
          <i class="fas fa-chevron-left"></i>
        </button>
        <button class="btn btn-sm btn-outline-primary" id="btn-next-page" disabled>
          <i class="fas fa-chevron-right"></i>
        </button>
      </div>
    </div>
  </div>
</div>
        </div>
      </div>
    </div>
  </div>
</div>

              

  <!-- Modal d'affichage des aléas -->
<div class="modal fade" id="aleas-modal" tabindex="-1" aria-labelledby="aleas-modal-label" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="aleas-modal-label">
          <i class="fas fa-clipboard-list me-2"></i>
          Aléas déclarés par <span id="aleas-operateur-name" class="fw-bold">--</span>
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fermer"></button>
      </div>
      <div class="modal-body">
        <!-- État de chargement -->
        <div id="aleas-loading" class="text-center py-4">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Chargement...</span>
          </div>
          <p class="mt-2">Chargement des aléas...</p>
        </div>
        
        <!-- Message d'erreur -->
        <div id="aleas-error" class="alert alert-danger" style="display: none;">
          Une erreur est survenue lors du chargement des aléas.
        </div>
        
        <!-- Message quand aucun aléa n'est trouvé -->
        <div id="aleas-empty" class="alert alert-info" style="display: none;">
          <i class="fas fa-info-circle me-2"></i>
          Aucun aléa déclaré par cet opérateur dans la période sélectionnée.
        </div>
        
        <!-- Tableau des aléas -->
        <div id="aleas-content" style="display: none;">
          <div class="mb-3 d-flex justify-content-between align-items-center">
            <div>
              <span class="badge bg-primary" id="aleas-count">0 aléas</span>
              <small class="text-muted ms-2" id="aleas-filters-info"></small>
            </div>
            <button class="btn btn-sm btn-outline-primary" id="btn-export-aleas">
              <i class="fas fa-file-export me-1"></i> Exporter
            </button>
          </div>
          
          <div class="table-responsive">
            <table class="table table-striped table-hover" id="aleas-table">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Type</th>
                  <th>Poste</th>
                  <th>Durée (h)</th>
                  <th>Commentaire</th>
                </tr>
              </thead>
              <tbody id="aleas-table-body">
                <!-- Rempli dynamiquement -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fermer</button>
      </div>
    </div>
  </div>
</div>
<!-- Modal d'affichage de tous les aléas -->
<div class="modal fade" id="all-aleas-modal" tabindex="-1" aria-labelledby="all-aleas-modal-label" aria-hidden="true">
  <div class="modal-dialog modal-xl">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="all-aleas-modal-label">
          <i class="fas fa-clipboard-list me-2"></i>
          Tous les aléas déclarés
        </h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fermer"></button>
      </div>
      <div class="modal-body">
        <!-- État de chargement -->
        <div id="all-aleas-loading" class="text-center py-4">
          <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">Chargement...</span>
          </div>
          <p class="mt-2">Chargement des aléas...</p>
        </div>
        
        <!-- Message d'erreur -->
        <div id="all-aleas-error" class="alert alert-danger" style="display: none;">
          Une erreur est survenue lors du chargement des aléas.
        </div>
        
        <!-- Message quand aucun aléa n'est trouvé -->
        <div id="all-aleas-empty" class="alert alert-info" style="display: none;">
          <i class="fas fa-info-circle me-2"></i>
          Aucun aléa trouvé pour la période sélectionnée.
        </div>
        
        <!-- Tableau des aléas -->
        <div id="all-aleas-content" style="display: none;">
          <div class="mb-3 d-flex justify-content-between align-items-center">
            <div>
              <span class="badge bg-primary" id="all-aleas-count">0 aléas</span>
              <small class="text-muted ms-2" id="all-aleas-filters-info"></small>
            </div>
            <div>
              <input type="text" class="form-control form-control-sm d-inline-block me-2" id="all-aleas-search" placeholder="Rechercher..." style="width: 200px;">
              <button class="btn btn-sm btn-outline-primary" id="btn-export-all-aleas">
                <i class="fas fa-file-export me-1"></i> Exporter
              </button>
            </div>
          </div>
          
          <div class="table-responsive">
            <table class="table table-striped table-hover" id="all-aleas-table">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Opérateur</th>
                  <th>Équipe</th>
                  <th>Poste</th>
                  <th>Type</th>
                  <th>Durée (h)</th>
                  <th>Commentaire</th>
                </tr>
              </thead>
              <tbody id="all-aleas-table-body">
                <!-- Rempli dynamiquement -->
              </tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fermer</button>
      </div>
    </div>
  </div>
</div>
<!-- Ajouter ce template dans la partie body du HTML, juste avant la fermeture de la balise body -->
<template id="filter-buttons-template">
  <div class="card mb-4">
    <div class="card-header">
      <i class="fas fa-filter me-2"></i>
      Filtrer par poste
    </div>
    <div class="card-body">
      <div class="btn-group btn-group-sm flex-wrap" role="group" id="poste-filter-buttons">
        <input type="radio" class="btn-check" name="poste-filter" id="poste-filter-all" value="all" checked>
        <label class="btn btn-outline-primary" for="poste-filter-all">
          Tous les postes
        </label>
        <!-- Les autres boutons seront générés dynamiquement -->
      </div>
    </div>
  </div>
</template>

  <!-- Bootstrap & Popper JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
  <!-- Script principal -->
  <script>
/**
    * Variables globales
    */
let allData = {};
let statsPostes = [];
let statsEquipes = [];
let statsOperateurs = [];
let statsTemporelles = {};
let detailOperateur = {};
let statsInactivite = {}; // Pour stocker les données agrégées
let inactiviteParetoChart, inactivitePostesChart, inactiviteEquipesChart, inactiviteEvolutionChart; // Instances Chart.js
let inactiviteTypeChart, inactiviteOperateursChart;

// Ajouter au début du script, juste après la déclaration des variables globales
window.onerror = function(msg, url, line, col, error) {
    console.error("Erreur globale:", msg, "à la ligne", line, "colonne", col);
    // Forcer l'affichage de l'interface si une erreur bloque le chargement
    document.getElementById('loader').style.display = 'none';
    document.getElementById('main-content').style.display = 'block';
    return false;
};

// Configuration
const CONFIG = {
    seuils: {
        rendement: { bon: 0.85, moyen: 0.7 },
        tai: { bon: 90, moyen: 80 },
        presence: { bon: 7.5, moyen: 6.5 }
    },
    colors: {
        primary: '#4361ee',
        success: '#4cc9f0',
        warning: '#ffbe0b',
        danger: '#f72585',
        colors: [
            'rgba(67, 97, 238, 0.7)',
            'rgba(76, 201, 240, 0.7)',
            'rgba(255, 190, 11, 0.7)',
            'rgba(247, 37, 133, 0.7)',
            'rgba(58, 12, 163, 0.7)',
            'rgba(114, 9, 183, 0.7)',
            'rgba(72, 149, 239, 0.7)',
            'rgba(76, 201, 240, 0.7)'
        ]
    },
    objectifs: {
        "EQ SOUDE": 0.95,
        "HFE": 1.0,
        "EQ MOUSSE": 0.8,
        "MARQUAGE": 0.8,
        "MASQUAGE": 0.7,
        "DEMASQUAGE": 0.7,
        "global": 0.84 // Objectif global utilisé par défaut
    }
};


// Filtres
let activeFilters = {
    dateDebut: null,
    dateFin: null,
    rendementMin: null,
    rendementMax: null,
    equipe: null,
    poste: null
};

/**
 * Initialisation
 */
document.addEventListener('DOMContentLoaded', function () {
    // Écouteurs d'événements
    initEventListeners();

    // Démarrer le chargement des données
    loadData();
});

/**
 * Initialiser les écouteurs d'événements
 */
function initEventListeners() {
    // Filtres
    document.getElementById('btn-toggle-filters').addEventListener('click', toggleFilters);
    document.getElementById('btn-reset-filters').addEventListener('click', resetFilters);
    document.getElementById('btn-apply-filters').addEventListener('click', applyFilters);
    document.getElementById('btn-clear-all-filters').addEventListener('click', clearAllFilters);

    // Bouton pour voir tous les aléas
    document.getElementById('btn-view-all-aleas').addEventListener('click', showAllAleas);

    // Période pour l'évolution
    document.querySelectorAll('input[name="periode-type"]').forEach(input => {
        input.addEventListener('change', updateEvolutionData);
    });

    // Recherche d'opérateurs
    document.getElementById('operateur-search').addEventListener('input', filterOperateursTable);
    document.getElementById('btn-clear-search').addEventListener('click', clearOperateurSearch);

    // Détail opérateur
    document.getElementById('btn-load-operateur').addEventListener('click', loadOperateurDetail);
    document.getElementById('btn-back-to-operateurs').addEventListener('click', function () {
        // Masquer l'onglet de détail
        document.getElementById('operateur-detail').classList.remove('show', 'active');

        // Afficher l'onglet des opérateurs
        const operateursTab = document.getElementById('operateurs');
        operateursTab.classList.add('show', 'active');

        // Activer le lien de navigation des opérateurs
        document.getElementById('tab-operateurs').classList.add('active');
    });

    // Navigation
    document.getElementById('tab-operateurs').addEventListener('click', function () {
        document.getElementById('operateur-selector').style.display = 'block';
    });

    document.querySelectorAll('.nav-link:not(#tab-operateurs)').forEach(tab => {
        tab.addEventListener('click', function () {
            document.getElementById('operateur-selector').style.display = 'none';
        });
    });

    // Ajouter l'écouteur d'événement pour le bouton d'application de l'objectif
    document.getElementById('btn-apply-objectif').addEventListener('click', function() {
        // Mettre à jour uniquement le graphique de comparaison sans recharger toutes les données
        updateComparisonChart();
    });
    
    // Permettre également l'application de l'objectif en appuyant sur Entrée dans le champ
    document.getElementById('objectif-valeur').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            updateComparisonChart();
        }
    });


    initInactiviteTab();

    // Initialiser les écouteurs d'événements pour l'onglet d'analyse des aléas
    initAleasAnalysisTab();
}

 
/**
 * Fonctions de gestion des filtres
 */
function toggleFilters() {
    const filtersContainer = document.getElementById('filters-container');
    filtersContainer.style.display = filtersContainer.style.display === 'none' ? 'block' : 'none';
}

function resetFilters() {
    document.getElementById('date-debut').value = '';
    document.getElementById('date-fin').value = '';
    document.getElementById('rendement-min').value = '';
    document.getElementById('rendement-max').value = '';
    document.getElementById('equipe-select').value = '';
    document.getElementById('poste-select').value = '';
}

function applyFilters() {
    // Afficher explicitement le loader
    document.getElementById('loader').style.display = 'block';
    document.getElementById('main-content').style.display = 'none';

    // Mettre à jour le message de chargement
    updateLoaderMessage("Application des filtres...");

    // Récupérer les valeurs des filtres
    const dateDebut = document.getElementById('date-debut').value;
    const dateFin = document.getElementById('date-fin').value;
    const rendementMin = document.getElementById('rendement-min').value;
    const rendementMax = document.getElementById('rendement-max').value;
    const equipe = document.getElementById('equipe-select').value;
    const poste = document.getElementById('poste-select').value;

    // Mettre à jour les filtres actifs
    activeFilters = {
        dateDebut: dateDebut || null,
        dateFin: dateFin || null,
        rendementMin: rendementMin !== '' ? parseFloat(rendementMin) : null,
        rendementMax: rendementMax !== '' ? parseFloat(rendementMax) : null,
        equipe: equipe || null,
        poste: poste || null
    };

    // Vérifier si au moins un filtre est actif
    const hasActiveFilters = dateDebut || dateFin ||
        rendementMin !== '' || rendementMax !== '' ||
        equipe || poste;

    // Important: Effacer le cache des opérateurs avec aléas quand les filtres changent
    window.cachedOperateursAvecAleas = [];
    console.log("Cache des opérateurs avec aléas effacé suite au changement de filtres");

    if (hasActiveFilters) {
        // Charger les données avec les filtres
        loadFilteredData();
    } else {
        // Recharger toutes les données (sans filtre)
        loadData();
    }

    // Masquer le panneau des filtres
    document.getElementById('filters-container').style.display = 'none';

    // Mettre à jour l'affichage des filtres actifs
    updateActiveFiltersDisplay();
}

function clearAllFilters() {
    resetFilters();
    activeFilters = {
        dateDebut: null,
        dateFin: null,
        rendementMin: null,
        rendementMax: null,
        equipe: null,
        poste: null
    };

    // Effacer le cache des opérateurs avec aléas
    window.cachedOperateursAvecAleas = [];
    console.log("Cache des opérateurs avec aléas effacé suite à la suppression des filtres");

    loadData(); // Relancer le chargement des données qui réappliquera la date la plus récente
    updateActiveFiltersDisplay();
}

function updateActiveFiltersDisplay() {
    const activeFiltersContainer = document.getElementById('active-filters');
    const filterBadgesContainer = document.getElementById('filter-badges');

    // Vérifier si des filtres sont actifs
    const hasActiveFilters =
        activeFilters.dateDebut !== null ||
        activeFilters.dateFin !== null ||
        activeFilters.rendementMin !== null ||
        activeFilters.rendementMax !== null ||
        activeFilters.equipe !== null ||
        activeFilters.poste !== null;

    if (!hasActiveFilters) {
        activeFiltersContainer.style.display = 'none';
        return;
    }

    // Afficher le conteneur
    activeFiltersContainer.style.display = 'block';

    // Vider et recréer les badges de filtres
    filterBadgesContainer.innerHTML = '';

    if (activeFilters.dateDebut) {
        addFilterBadge('Depuis: ' + formatDate(activeFilters.dateDebut), 'dateDebut');
    }

    if (activeFilters.dateFin) {
        addFilterBadge('Jusqu\'à: ' + formatDate(activeFilters.dateFin), 'dateFin');
    }

    if (activeFilters.rendementMin !== null) {
        addFilterBadge('Rendement min: ' + activeFilters.rendementMin.toFixed(2), 'rendementMin');
    }

    if (activeFilters.rendementMax !== null) {
        addFilterBadge('Rendement max: ' + activeFilters.rendementMax.toFixed(2), 'rendementMax');
    }

    if (activeFilters.equipe) {
        addFilterBadge('Équipe: ' + activeFilters.equipe, 'equipe');
    }

    if (activeFilters.poste) {
        addFilterBadge('Poste: ' + activeFilters.poste, 'poste');
    }
}

function addFilterBadge(text, filterKey) {
    const badge = document.createElement('div');
    badge.className = 'filter-badge';
    badge.innerHTML = `
          ${text}
          <span class="close" data-filter="${filterKey}">×</span>
        `;

    document.getElementById('filter-badges').appendChild(badge);

    // Ajouter un écouteur d'événement pour supprimer ce filtre
    badge.querySelector('.close').addEventListener('click', function () {
        const filterToRemove = this.getAttribute('data-filter');
        activeFilters[filterToRemove] = null;

        // Si c'est un filtre de date ou de rendement, vider aussi le champ correspondant
        if (filterToRemove === 'dateDebut') document.getElementById('date-debut').value = '';
        if (filterToRemove === 'dateFin') document.getElementById('date-fin').value = '';
        if (filterToRemove === 'rendementMin') document.getElementById('rendement-min').value = '';
        if (filterToRemove === 'rendementMax') document.getElementById('rendement-max').value = '';
        if (filterToRemove === 'equipe') document.getElementById('equipe-select').value = '';
        if (filterToRemove === 'poste') document.getElementById('poste-select').value = '';

        // Recharger les données
        loadFilteredData();

        // Mettre à jour l'affichage des filtres
        updateActiveFiltersDisplay();
    });
}

function formatDate(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleDateString();
}


function updateLoaderMessage(message) {
    const loaderMessageElement = document.querySelector('#loader p');
    if (loaderMessageElement) {
        loaderMessageElement.textContent = message;
    }
}
/**
 * Chargement des données
 */
function loadData() {
    updateLoaderMessage("Connexion au serveur...");

    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Test de connexion réussi:", response);
            updateLoaderMessage("Connexion établie. Chargement des opérateurs...");

            loadAllOperators();

            google.script.run
                .withSuccessHandler(function (response) {
                    console.log("Récupération de la date la plus récente:", response);

                    if (response && response.success && response.date) {
                        updateLoaderMessage(`Filtrage des données à partir du ${response.date}...`);

                        activeFilters.dateDebut = response.date;
                        activeFilters.dateFin = response.date;

                        document.getElementById('date-debut').value = response.date;
                        document.getElementById('date-fin').value = response.date;

                        loadFilteredData();
                    } else {
                        updateLoaderMessage("Chargement des données principales...");
                        loadMainData();
                    }
                })
                .withFailureHandler(function (error) {
                    console.error("Erreur lors de la récupération de la date la plus récente:", error);
                    updateLoaderMessage("Erreur de chargement. Récupération des données principales...");
                    loadMainData();
                })
                .obtenirDatePlusRecente();
        })
        .withFailureHandler(handleError)
        .testConnection();
}

// 2. Ajouter une fonction pour charger tous les opérateurs indépendamment des filtres
function loadAllOperators() {
    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Liste complète des opérateurs reçue");
            if (response && response.success && response.operateurs) {
                // Remplir le sélecteur d'opérateurs avec la liste complète
                populateOperateurSelectorWithData(response.operateurs);
            } else {
                console.error("Erreur lors de la récupération de la liste des opérateurs", response);
            }
        })
        .withFailureHandler(function (error) {
            console.error("Erreur lors de la récupération de la liste des opérateurs:", error);
        })
        .obtenirListeOperateurs();
}

function populateOperateurSelectorWithData(operateurs) {
    const operateurSelect = document.getElementById('operateur-select');
    operateurSelect.innerHTML = '<option value="">Sélectionner un opérateur</option>';

    operateurs.forEach(operateur => {
        const option = document.createElement('option');
        option.value = operateur;
        option.textContent = operateur;
        operateurSelect.appendChild(option);
    });
}

function loadMainData() {
    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Données principales reçues");
            allData = response;

            // Remplir les sélecteurs de filtres
            populateFilterSelectors();

            // Charger les statistiques complémentaires
            loadStats();
        })
        .withFailureHandler(handleError)
        .obtenirDonneesReduites();
}

function loadFilteredData() {
    updateLoaderMessage("Filtrage des données en cours...");

    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Données filtrées reçues");
            updateLoaderMessage("Mise à jour des filtres...");

            allData = response;

            populateFilterSelectors();

            updateLoaderMessage("Chargement des statistiques...");
            loadStats();
        })
        .withFailureHandler(function (error) {
            // Assurez-vous de cacher le loader en cas d'erreur
            document.getElementById('loader').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';
            handleError(error);
        })
        .obtenirDonneesReduitesFiltrees(activeFilters);
        if (inactiviteData) {
        loadInactiviteData(); // Recharger avec les nouveaux filtres
    }
}



function loadStats() {
    updateLoaderMessage("Chargement des statistiques principales...");
    
    // Définir un délai maximum pour le chargement
    setTimeout(function() {
        // Si le loader est toujours visible après 15 secondes, on force l'affichage
        if (document.getElementById('loader').style.display !== 'none') {
            console.warn("Délai de chargement dépassé, affichage forcé de l'interface");
            document.getElementById('loader').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';
        }
    }, 15000);
    
    // Lancer les chargements en parallèle
    loadPostesStats();
    loadEquipesStats();
    loadOperateursStats();
    loadTemporellesStats();
    
    // Essayer de charger l'inactivité, mais ne pas bloquer si ça échoue
    try {
        loadInactiviteStats();
    } catch (err) {
        console.error("Erreur chargement inactivité:", err);
        // Initialiser avec des données vides
        statsInactivite = { total: { duree: 0, nbEntrees: 0 } };
    }
    
    // Charger les données d'aléas avec un léger délai
    setTimeout(function() {
        try {
            loadAleasDurations();
        } catch (err) {
            console.error("Erreur chargement aléas:", err);
        }
    }, 500);
}

function loadInactiviteStats() {
  console.log("Chargement des statistiques d'inactivité...");
  
  // Afficher un message de chargement
  const loadingDiv = document.getElementById('inactivite-loading');
  const contentDiv = document.getElementById('inactivite-content');
  const errorDiv = document.getElementById('inactivite-error');
  const emptyDiv = document.getElementById('inactivite-empty');
  
  if (loadingDiv) loadingDiv.style.display = 'block';
  if (contentDiv) contentDiv.style.display = 'none';
  if (errorDiv) errorDiv.style.display = 'none';
  if (emptyDiv) emptyDiv.style.display = 'none';
  
  google.script.run
    .withSuccessHandler(function (response) {
      console.log("Statistiques d'inactivité reçues", response);
      
      if (loadingDiv) loadingDiv.style.display = 'none';
      
      if (response && response.success) {
        // Stocker les données
        statsInactivite = response.stats || {};
        console.log("Données d'inactivité chargées:", statsInactivite);
        
        // Vérifier si les données sont vides
        if (!statsInactivite.total || 
            statsInactivite.total.duree === 0 || 
            !statsInactivite.parType || 
            Object.keys(statsInactivite.parType).length === 0) {
          
          if (emptyDiv) emptyDiv.style.display = 'block';
          return;
        }
        
        // Mettre à jour l'interface
        updateInactiviteTab();
        if (contentDiv) contentDiv.style.display = 'block';
      } else {
        if (errorDiv) {
          errorDiv.textContent = "Erreur : " + (response?.message || "Impossible de charger les données");
          errorDiv.style.display = 'block';
        }
      }
    })
    .withFailureHandler(function(error) {
      console.error("Échec du chargement des statistiques d'inactivité", error);
      
      if (loadingDiv) loadingDiv.style.display = 'none';
      if (errorDiv) {
        errorDiv.textContent = "Erreur serveur : " + error;
        errorDiv.style.display = 'block';
      }
    })
    .obtenirStatistiquesInactivite(activeFilters);
}

function loadPostesStats() {
    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Statistiques par poste reçues");
            updateLoaderMessage("Chargement des statistiques par poste...");
            statsPostes = response;
            updateUI();
        })
        .withFailureHandler(handleError)
        .obtenirStatistiquesParPoste(activeFilters);
}

function loadEquipesStats() {
    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Statistiques par équipe reçues");
            updateLoaderMessage("Chargement des statistiques par équipe...");
            statsEquipes = response;
            updateUI();
        })
        .withFailureHandler(handleError)
        .obtenirStatistiquesParEquipe(activeFilters);
}

function loadOperateursStats() {
    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Statistiques par opérateur reçues");
            updateLoaderMessage("Chargement des performances des opérateurs...");
            statsOperateurs = response;
            updateUI();
        })
        .withFailureHandler(handleError)
        .obtenirPerformancesOperateurs(activeFilters);
}

function loadTemporellesStats() {
    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Statistiques temporelles reçues");
            updateLoaderMessage("Chargement des données temporelles...");
            statsTemporelles = response;
            updateUI();
        })
        .withFailureHandler(handleError)
        .obtenirDonneesTemporelles(activeFilters);
}

// Variables globales pour l'onglet Inactivité
let inactiviteData = null;


/**
 * Initialisation de l'onglet d'inactivité
 */
function initInactiviteTab() {
  console.log("Initialisation de l'onglet d'inactivité");
  
  // Écouteur d'événement pour charger les données quand on clique sur l'onglet
  document.getElementById('tab-inactivite').addEventListener('click', function() {
    console.log("Clic sur l'onglet Inactivité");
    document.getElementById('operateur-selector').style.display = 'none';
    
    // Charger les données si elles n'ont pas déjà été chargées
    if (!statsInactivite || !statsInactivite.total) {
      loadInactiviteStats();
    } else {
      // Si déjà chargées, juste mettre à jour l'interface
      updateInactiviteTab();
    }
  });
  
  // Ajouter un écouteur pour le bouton de rafraîchissement
  const refreshButton = document.getElementById('btn-refresh-inactivite');
  if (refreshButton) {
    refreshButton.addEventListener('click', loadInactiviteStats);
  }
  
  // Ajouter des écouteurs pour les boutons de type de période
  document.querySelectorAll('input[name="inactivite-periode-type"]').forEach(input => {
    input.addEventListener('change', updateInactiviteEvolutionChart);
  });
}


function loadInactiviteDataDirectly() {
  console.log("Chargement direct des données d'inactivité");
  
  // Afficher le chargement
  document.getElementById('inactivite-loading').style.display = 'block';
  document.getElementById('inactivite-content').style.display = 'none';
  document.getElementById('inactivite-error').style.display = 'none';
  
  // Appel serveur
  google.script.run
    .withSuccessHandler(function(response) {
      console.log("Données d'inactivité reçues", response);
      
      document.getElementById('inactivite-loading').style.display = 'none';
      
      if (response && response.success) {
        // Stocker les données
        const inactiviteData = response.stats || {};
        
        // Vérifier si les données sont vides
        if (!inactiviteData.total) {
          document.getElementById('inactivite-error').textContent = "Aucune donnée d'inactivité disponible";
          document.getElementById('inactivite-error').style.display = 'block';
          return;
        }
        
        // Mettre à jour l'interface
        updateInactiviteUIDirectly(inactiviteData);
      } else {
        document.getElementById('inactivite-error').textContent = "Erreur : " + (response?.message || "Impossible de charger les données");
        document.getElementById('inactivite-error').style.display = 'block';
      }
    })
    .withFailureHandler(function(error) {
      console.error("Échec du chargement des données d'inactivité", error);
      
      document.getElementById('inactivite-loading').style.display = 'none';
      document.getElementById('inactivite-error').textContent = "Erreur serveur : " + error;
      document.getElementById('inactivite-error').style.display = 'block';
    })
    .obtenirStatistiquesInactivite(activeFilters);
}

// Fonction pour mettre à jour l'interface d'inactivité
function updateInactiviteUIDirectly(data) {
  console.log("Mise à jour directe de l'interface d'inactivité avec", data);
  
  try {
    // Afficher le contenu
    document.getElementById('inactivite-content').style.display = 'block';
    
    // Mise à jour des indicateurs
    const totalInactivite = data.total?.duree || 0;
    const totalPresence = data.total?.presenceTotal || 0;
    const nbEntrees = data.total?.nbEntrees || 0;
    
    // Indicateur 1: Total heures d'inactivité
    const totalElement = document.getElementById('inactivite-total');
    if (totalElement) totalElement.textContent = totalInactivite.toFixed(2);
    
    // Indicateur 2: Pourcentage du temps total
    const pourcentage = totalPresence > 0 ? (totalInactivite / totalPresence) * 100 : 0;
    const pourcentageElement = document.getElementById('inactivite-pourcentage');
    if (pourcentageElement) pourcentageElement.textContent = pourcentage.toFixed(1) + '%';
    
    // Indicateur 3: Moyenne par opérateur
    const nbOperateurs = data.parOperateur ? Object.keys(data.parOperateur).length : 0;
    const moyenneOperateur = nbOperateurs > 0 ? totalInactivite / nbOperateurs : 0;
    const moyenneOperateurElement = document.getElementById('inactivite-moyenne-operateur');
    if (moyenneOperateurElement) moyenneOperateurElement.textContent = moyenneOperateur.toFixed(2);
    
    // Indicateur 4: Moyenne par équipe
    const nbEquipes = data.parEquipe ? Object.keys(data.parEquipe).length : 0;
    const moyenneEquipe = nbEquipes > 0 ? totalInactivite / nbEquipes : 0;
    const moyenneEquipeElement = document.getElementById('inactivite-moyenne-equipe');
    if (moyenneEquipeElement) moyenneEquipeElement.textContent = moyenneEquipe.toFixed(2);
    
    // Création des graphiques
    createInactiviteTypeChartDirectly(data);
    // Commentez les autres fonctions de graphique si elles ne sont pas encore implémentées
    // createInactiviteOperateursChartDirectly(data);
    // createInactiviteEquipesChartDirectly(data);
    // updateInactiviteEvolutionChartDirectly(data);
    
  } catch (error) {
    console.error("Erreur lors de la mise à jour de l'interface d'inactivité", error);
    document.getElementById('inactivite-error').textContent = "Erreur d'affichage : " + error.message;
    document.getElementById('inactivite-error').style.display = 'block';
    document.getElementById('inactivite-content').style.display = 'none';
  }
}

// Fonction pour créer le graphique par type d'inactivité
function createInactiviteTypeChartDirectly(data) {
  console.log("Création du graphique de type d'inactivité");
  
  const canvas = document.getElementById('chart-inactivite-types');
  if (!canvas) {
    console.error("Élément canvas 'chart-inactivite-types' introuvable");
    return;
  }
  
  // Détruire le graphique existant s'il y en a un
  if (window.inactiviteTypeChart) {
    window.inactiviteTypeChart.destroy();
  }
  
  // Vérifier que nous avons des données par type
  if (!data.parType || Object.keys(data.parType).length === 0) {
    console.warn("Pas de données par type disponibles");
    return;
  }
  
  // Préparation des données
  const types = Object.keys(data.parType);
  const values = types.map(type => data.parType[type].duree || 0);
  
  // Génération des couleurs
  const colors = types.map((_, index) => {
    const hue = (index * 360 / types.length) % 360;
    return `hsla(${hue}, 70%, 60%, 0.7)`;
  });
  
  // Création du graphique
  window.inactiviteTypeChart = new Chart(canvas.getContext('2d'), {
    type: 'pie',
    data: {
      labels: types,
      datasets: [{
        label: "Heures d'inactivité",
        data: values,
        backgroundColor: colors,
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'right'
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = context.parsed || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : '0.0';
              return `${label}: ${value.toFixed(2)}h (${percentage}%)`;
            }
          }
        }
      }
    }
  });
}
/**
 * Chargement des données d'inactivité
 */
function loadInactiviteData() {
  // Afficher le chargement
  document.getElementById('inactivite-loading').style.display = 'block';
  document.getElementById('inactivite-content').style.display = 'none';
  document.getElementById('inactivite-error').style.display = 'none';

  // Appeler la fonction côté serveur
  google.script.run
    .withSuccessHandler(function(response) {
      document.getElementById('inactivite-loading').style.display = 'none';

      if (response.erreur) {
        // Afficher l'erreur
        document.getElementById('inactivite-error').textContent = response.erreur;
        document.getElementById('inactivite-error').style.display = 'block';
      } else {
        // Stocker les données
        inactiviteData = response;

        // Mettre à jour l'interface
        updateInactiviteUI();
        document.getElementById('inactivite-content').style.display = 'block';
      }
    })
    .withFailureHandler(function(error) {
      document.getElementById('inactivite-loading').style.display = 'none';
      document.getElementById('inactivite-error').textContent = "Erreur: " + error;
      document.getElementById('inactivite-error').style.display = 'block';
    })
    .obtenirDonneesInactivite(activeFilters);
}

/**
 * Mise à jour de l'interface d'inactivité
 */
function updateInactiviteUI() {
  try {
    // S'assurer que les éléments existent avant de les manipuler
    const contentDiv = document.getElementById('inactivite-content');
    if (!contentDiv) {
      console.error("Élément 'inactivite-content' introuvable");
      return;
    }
    
    // Masquer le chargement et les erreurs, afficher le contenu
    document.getElementById('inactivite-loading').style.display = 'none';
    document.getElementById('inactivite-error').style.display = 'none';
    contentDiv.style.display = 'block';
    
    // Mettre à jour l'interface
    updateInactiviteIndicators();
    createInactiviteTypeChart();
    createInactiviteOperateursChart();
    createInactiviteEquipesChart();
    updateInactiviteEvolutionChart();
    updateInactiviteTable();
  } catch (error) {
    console.error("Erreur lors de la mise à jour de l'interface d'inactivité:", error);
    const errorDiv = document.getElementById('inactivite-error');
    if (errorDiv) {
      errorDiv.textContent = "Erreur: " + error.message;
      errorDiv.style.display = 'block';
      document.getElementById('inactivite-content').style.display = 'none';
    }
  }
}

// Cette fonction met à jour les indicateurs d'inactivité
function updateInactiviteIndicators() {
  // Extraction des données
  const totalInactivite = statsInactivite.total?.duree || 0;
  const nbEntreesTotal = statsInactivite.total?.nbEntrees || 0;
  const totalPresence = statsInactivite.total?.presenceTotal || 0;
  
  // 1. Modification du "Total heures d'inactivité" - reste inchangé
  document.getElementById('inactivite-total').textContent = totalInactivite.toFixed(2);

  // 2. Modification du "% du temps total" avec la nouvelle formule
  const pourcentageInactivite = (totalPresence + totalInactivite) > 0 ? 
      (totalInactivite / (totalPresence + totalInactivite)) * 100 : 0;
  document.getElementById('inactivite-pourcentage').textContent = pourcentageInactivite.toFixed(1) + '%';
  
  // 3. Modification de "Moyenne par opérateur" en "Taux de congés"
  // Chercher les heures de congés dans les types d'inactivité
  let totalConges = 0;
  if (statsInactivite.parType && statsInactivite.parType['CONGES']) {
    totalConges = statsInactivite.parType['CONGES'].duree || 0;
  }
  
  // Calculer le taux de congés
  const tauxConges = (totalPresence + totalInactivite) > 0 ? 
      (totalConges / (totalPresence + totalInactivite)) * 100 : 0;
  
  // Mettre à jour le texte affiché
  document.getElementById('inactivite-moyenne-operateur').textContent = tauxConges.toFixed(2) + '%';
  document.querySelector('#inactivite-moyenne-operateur').nextElementSibling.textContent = "Taux de congés";
  
  // 4. Modification de "Moyenne par équipe" en "Total hors congés"
  const totalHorsConges = totalInactivite - totalConges;
  document.getElementById('inactivite-moyenne-equipe').textContent = totalHorsConges.toFixed(2);
  document.querySelector('#inactivite-moyenne-equipe').nextElementSibling.textContent = "Inactivité hors congés (h)";
}

/**
 * Créer le graphique de répartition par type d'inactivité
 */
function createInactiviteTypeChart() {
  console.log("Création du graphique de type d'inactivité");
  
  const canvas = document.getElementById('chart-inactivite-types');
  if (!canvas) {
    console.error("Élément canvas 'chart-inactivite-types' introuvable");
    return;
  }
  
  // Détruire le graphique existant s'il y en a un
  if (window.inactiviteTypeChart) {
    window.inactiviteTypeChart.destroy();
  }
  
  // Vérifier que nous avons des données par type
  if (!statsInactivite.parType || Object.keys(statsInactivite.parType).length === 0) {
    console.warn("Pas de données par type disponibles");
    return;
  }
  
  // Préparation des données
  const types = Object.keys(statsInactivite.parType);
  const values = types.map(type => statsInactivite.parType[type].duree || 0);
  
  // Générer des couleurs
  const colors = types.map((_, index) => {
    const hue = (index * 360 / types.length) % 360;
    return `hsla(${hue}, 70%, 60%, 0.7)`;
  });
  
  // Création du graphique
  window.inactiviteTypeChart = new Chart(canvas.getContext('2d'), {
    type: 'pie',
    data: {
      labels: types,
      datasets: [{
        label: "Heures d'inactivité",
        data: values,
        backgroundColor: colors,
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'right'
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = context.parsed || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : '0.0';
              return `${label}: ${value.toFixed(2)}h (${percentage}%)`;
            }
          }
        }
      }
    }
  });
}

/**
 * Créer le graphique des opérateurs par inactivité
 */
function createInactiviteOperateursChart() {
  if (!inactiviteData) return;

  const ctx = document.getElementById('chart-inactivite-operateurs').getContext('2d');

  // Détruire le graphique s'il existe déjà
  if (inactiviteOperateursChart) {
    inactiviteOperateursChart.destroy();
  }

  // Préparer les données
  const operateurs = Object.keys(inactiviteData.statsByOperateur);
  const values = operateurs.map(op => inactiviteData.statsByOperateur[op].total);

  // Trier par valeur décroissante
  const sortedIndices = values.map((v, i) => i).sort((a, b) => values[b] - values[a]);
  
  // Prendre les 10 premiers
  const top10Indices = sortedIndices.slice(0, 10);
  const top10Operateurs = top10Indices.map(i => operateurs[i]);
  const top10Values = top10Indices.map(i => values[i]);

  // Créer le graphique
  inactiviteOperateursChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: top10Operateurs,
      datasets: [{
        label: 'Heures d\'inactivité',
        data: top10Values,
        backgroundColor: CONFIG.colors.primary,
        borderWidth: 0,
        borderRadius: 6,
        maxBarThickness: 50
      }]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              return `Inactivité: ${context.parsed.x.toFixed(2)}h`;
            },
            afterLabel: function(context) {
              const operateur = top10Operateurs[context.dataIndex];
              const data = inactiviteData.statsByOperateur[operateur];
              
              const typeDetails = [];
              Object.keys(data.parType).forEach(type => {
                if (data.parType[type] > 0) {
                  typeDetails.push(`${type}: ${data.parType[type].toFixed(2)}h`);
                }
              });
              
              return typeDetails;
            }
          }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Heures d\'inactivité'
          }
        },
        y: {
          grid: {
            display: false
          }
        }
      }
    }
  });
}

/**
 * Créer le graphique des équipes par inactivité
 */
function createInactiviteEquipesChart() {
  if (!inactiviteData) return;

  const ctx = document.getElementById('chart-inactivite-equipes').getContext('2d');

  // Détruire le graphique s'il existe déjà
  if (inactiviteEquipesChart) {
    inactiviteEquipesChart.destroy();
  }

  // Préparer les données
  const equipes = Object.keys(inactiviteData.statsByEquipe);
  const values = equipes.map(eq => inactiviteData.statsByEquipe[eq].total);
  const entrees = equipes.map(eq => inactiviteData.statsByEquipe[eq].entrees);
  const moyennes = equipes.map((eq, i) => values[i] / entrees[i]);

  // Créer le graphique
  inactiviteEquipesChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: equipes,
      datasets: [
        {
          label: 'Total inactivité',
          data: values,
          backgroundColor: CONFIG.colors.colors[0],
          borderWidth: 0,
          borderRadius: 6,
          maxBarThickness: 50,
          yAxisID: 'y'
        },
        {
          label: 'Moyenne par entrée',
          data: moyennes,
          type: 'line',
          borderColor: CONFIG.colors.colors[1],
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: 4,
          yAxisID: 'y1'
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          mode: 'index',
          callbacks: {
            label: function(context) {
              if (context.dataset.label === 'Total inactivité') {
                return `Total: ${context.parsed.y.toFixed(2)}h`;
              } else {
                return `Moyenne: ${context.parsed.y.toFixed(2)}h`;
              }
            },
            afterBody: function(context) {
              if (!context || context.length === 0) return [];
              
              const equipe = equipes[context[0].dataIndex];
              const data = inactiviteData.statsByEquipe[equipe];
              
              const details = [`Entrées: ${data.entrees}`];
              
              // Ajouter les détails par type
              Object.keys(data.parType).forEach(type => {
                if (data.parType[type] > 0) {
                  details.push(`${type}: ${data.parType[type].toFixed(2)}h`);
                }
              });
              
              return details;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Total (h)'
          }
        },
        y1: {
          position: 'right',
          beginAtZero: true,
          title: {
            display: true,
            text: 'Moyenne (h)'
          },
          grid: {
            display: false
          }
        },
        x: {
          grid: {
            display: false
          }
        }
      }
    }
  });
}

/**
 * Mettre à jour le graphique d'évolution de l'inactivité (suite)
 */
function updateInactiviteEvolutionChart() {
  if (!inactiviteData) return;

  const ctx = document.getElementById('chart-inactivite-evolution').getContext('2d');

  // Détruire le graphique s'il existe déjà
  if (inactiviteEvolutionChart) {
    inactiviteEvolutionChart.destroy();
  }

  // Déterminer le type de période
  const periodeType = document.querySelector('input[name="inactivite-periode-type"]:checked').value;

  // Agréger les données par période
  const donneesParPeriode = {};
  
  inactiviteData.donnees.forEach(item => {
    if (!item.date) return;
    
    const date = new Date(item.date);
    const annee = date.getFullYear();
    const mois = date.getMonth() + 1;
    
    let periode;
    if (periodeType === 'mois') {
      periode = `${annee}-${mois.toString().padStart(2, '0')}`;
    } else {
      // Calculer la semaine de l'année
      const premierJanvier = new Date(date.getFullYear(), 0, 1);
      const jours = Math.floor((date - premierJanvier) / (24 * 60 * 60 * 1000));
      const semaine = Math.ceil((jours + premierJanvier.getDay() + 1) / 7);
      periode = `${annee}-S${semaine.toString().padStart(2, '0')}`;
    }
    
    // Initialiser la période si nécessaire
    if (!donneesParPeriode[periode]) {
      donneesParPeriode[periode] = {
        inactiviteTotal: 0,
        inactiviteParType: {},
        entrees: 0
      };
      
      inactiviteData.typesInactivite.forEach(type => {
        donneesParPeriode[periode].inactiviteParType[type] = 0;
      });
    }
    
    // Ajouter les valeurs d'inactivité
    donneesParPeriode[periode].inactiviteTotal += item.inactiviteTotal;
    donneesParPeriode[periode].entrees++;
    
    Object.keys(item.inactiviteParType).forEach(type => {
      donneesParPeriode[periode].inactiviteParType[type] += item.inactiviteParType[type];
    });
  });
  
  // Convertir en tableaux pour le graphique
  const periodes = Object.keys(donneesParPeriode).sort();
  const inactiviteTotal = periodes.map(p => donneesParPeriode[p].inactiviteTotal);
  const moyenneParEntree = periodes.map((p, i) => 
    donneesParPeriode[p].entrees > 0 ? donneesParPeriode[p].inactiviteTotal / donneesParPeriode[p].entrees : 0
  );
  
  // Préparer les datasets pour chaque type d'inactivité
  const datasets = [];
  
  // Dataset pour le total
  datasets.push({
    label: 'Total inactivité',
    data: inactiviteTotal,
    backgroundColor: CONFIG.colors.primary,
    borderColor: CONFIG.colors.primary,
    borderWidth: 2,
    type: 'bar',
    yAxisID: 'y',
    order: 1
  });
  
  // Dataset pour la moyenne par entrée
  datasets.push({
    label: 'Moyenne par entrée',
    data: moyenneParEntree,
    borderColor: CONFIG.colors.colors[1],
    backgroundColor: 'transparent',
    borderWidth: 2,
    pointRadius: 4,
    type: 'line',
    yAxisID: 'y1',
    order: 0
  });
  
  // Créer le graphique
  inactiviteEvolutionChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: periodes,
      datasets: datasets
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        tooltip: {
          mode: 'index',
          callbacks: {
            afterTitle: function(context) {
              if (!context || context.length === 0) return [];
              const periode = periodes[context[0].dataIndex];
              return [`Entrées: ${donneesParPeriode[periode].entrees}`];
            }
          }
        },
        title: {
          display: true,
          text: `Évolution de l'inactivité par ${periodeType === 'mois' ? 'mois' : 'semaine'}`,
          font: {
            size: 16,
            weight: 'bold'
          }
        }
      },
      scales: {
        y: {
          type: 'linear',
          display: true,
          position: 'left',
          beginAtZero: true,
          title: {
            display: true,
            text: 'Total (h)'
          }
        },
        y1: {
          type: 'linear',
          display: true,
          position: 'right',
          beginAtZero: true,
          title: {
            display: true,
            text: 'Moyenne (h)'
          },
          grid: {
            display: false
          }
        },
        x: {
          grid: {
            display: false
          }
        }
      }
    }
  });
}

/**
 * Mettre à jour le tableau détaillé des types d'inactivité
 */
function updateInactiviteTable() {
  if (!inactiviteData) return;
  
  const tbody = document.getElementById('table-inactivite-types').querySelector('tbody');
  tbody.innerHTML = '';
  
  // Calculer le total global d'inactivité
  let totalInactiviteGlobal = 0;
  Object.keys(inactiviteData.statsByType).forEach(type => {
    totalInactiviteGlobal += inactiviteData.statsByType[type].total;
  });
  
  // Créer un tableau pour trier les données
  const typesArray = Object.keys(inactiviteData.statsByType).map(type => ({
    nom: type,
    total: inactiviteData.statsByType[type].total,
    moyenne: inactiviteData.statsByType[type].moyenne,
    max: inactiviteData.statsByType[type].max,
    maxOperateur: inactiviteData.statsByType[type].maxOperateur,
    pourcentage: totalInactiviteGlobal > 0 ? (inactiviteData.statsByType[type].total / totalInactiviteGlobal) * 100 : 0
  }));
  
  // Trier par total décroissant
  typesArray.sort((a, b) => b.total - a.total);
  
  // Créer les lignes du tableau
  typesArray.forEach(type => {
    const tr = document.createElement('tr');
    
    // Déterminer le style d'affichage (couleur) en fonction du pourcentage
    let statusClass = '';
    if (type.pourcentage > 30) {
      statusClass = 'table-danger';
    } else if (type.pourcentage > 15) {
      statusClass = 'table-warning';
    } else {
      statusClass = 'table-success';
    }
    
    tr.className = statusClass;
    
    tr.innerHTML = `
      <td><strong>${type.nom}</strong></td>
      <td>${type.total.toFixed(2)}</td>
      <td>${type.moyenne.toFixed(2)}</td>
      <td>${type.max.toFixed(2)}</td>
      <td>${type.maxOperateur}</td>
      <td>${type.pourcentage.toFixed(2)}%</td>
    `;
    
    tbody.appendChild(tr);
  });
}
/**
* Fonction pour afficher tous les aléas
*/
function showAllAleas() {
    // Initialiser la modale
    resetAllAleasModal();

    // Afficher le spinner de chargement
    document.getElementById('all-aleas-loading').style.display = 'block';
    document.getElementById('all-aleas-content').style.display = 'none';
    document.getElementById('all-aleas-error').style.display = 'none';
    document.getElementById('all-aleas-empty').style.display = 'none';

    // Afficher la modale
    var allAleasModal = new bootstrap.Modal(document.getElementById('all-aleas-modal'));
    allAleasModal.show();

    // Récupérer les aléas avec les filtres actuels
    google.script.run
        .withSuccessHandler(function (response) {
            document.getElementById('all-aleas-loading').style.display = 'none';

            if (response.success) {
                if (response.aleas && response.aleas.length > 0) {
                    // Mémoriser les aléas dans une variable globale pour la recherche
                    window.allAleasData = response.aleas;

                    // Afficher les aléas dans le tableau
                    populateAllAleasTable(response.aleas);
                    document.getElementById('all-aleas-content').style.display = 'block';

                    // Mettre à jour le compteur d'aléas
                    document.getElementById('all-aleas-count').textContent = response.aleas.length + ' aléa' + (response.aleas.length > 1 ? 's' : '');

                    // Afficher les informations sur les filtres
                    if (activeFilters && (activeFilters.dateDebut || activeFilters.dateFin || activeFilters.poste || activeFilters.equipe)) {
                        let filtersInfo = "Filtré par: ";
                        let hasFilter = false;

                        if (activeFilters.dateDebut && activeFilters.dateFin) {
                            filtersInfo += "période du " + formatDate(activeFilters.dateDebut) + " au " + formatDate(activeFilters.dateFin);
                            hasFilter = true;
                        } else if (activeFilters.dateDebut) {
                            filtersInfo += "date après " + formatDate(activeFilters.dateDebut);
                            hasFilter = true;
                        } else if (activeFilters.dateFin) {
                            filtersInfo += "date avant " + formatDate(activeFilters.dateFin);
                            hasFilter = true;
                        }

                        if (activeFilters.poste) {
                            filtersInfo += (hasFilter ? ", " : "") + "poste '" + activeFilters.poste + "'";
                            hasFilter = true;
                        }

                        if (activeFilters.equipe) {
                            filtersInfo += (hasFilter ? ", " : "") + "équipe '" + activeFilters.equipe + "'";
                        }

                        document.getElementById('all-aleas-filters-info').textContent = filtersInfo;
                    } else {
                        document.getElementById('all-aleas-filters-info').textContent = "Aucun filtre appliqué";
                    }

                    // Ajouter l'écouteur d'événement pour la recherche
                    document.getElementById('all-aleas-search').addEventListener('input', filterAllAleasTable);

                } else {
                    // Aucun aléa trouvé
                    document.getElementById('all-aleas-empty').style.display = 'block';
                }
            } else {
                // Erreur
                document.getElementById('all-aleas-error').textContent = response.message || "Une erreur est survenue lors du chargement des aléas.";
                document.getElementById('all-aleas-error').style.display = 'block';
            }
        })
        .withFailureHandler(function (error) {
            document.getElementById('all-aleas-loading').style.display = 'none';
            document.getElementById('all-aleas-error').textContent = "Erreur: " + error;
            document.getElementById('all-aleas-error').style.display = 'block';
        })
        .obtenirTousAleas(activeFilters);
}

/**
 * Filtre le tableau de tous les aléas en fonction de la recherche
 */
function filterAllAleasTable() {
    const searchTerm = document.getElementById('all-aleas-search').value.toLowerCase().trim();

    if (!window.allAleasData) return;

    // Si la recherche est vide, afficher tous les aléas
    if (!searchTerm) {
        populateAllAleasTable(window.allAleasData);
        document.getElementById('all-aleas-count').textContent = window.allAleasData.length + ' aléa' + (window.allAleasData.length > 1 ? 's' : '');
        return;
    }

    // Filtrer les aléas
    const filteredAleas = window.allAleasData.filter(alea => {
        return (
            (alea.operateur && alea.operateur.toLowerCase().includes(searchTerm)) ||
            (alea.poste && alea.poste.toLowerCase().includes(searchTerm)) ||
            (alea.equipe && alea.equipe.toLowerCase().includes(searchTerm)) ||
            (alea.typeAlea && alea.typeAlea.toLowerCase().includes(searchTerm)) ||
            (alea.commentaire && alea.commentaire.toLowerCase().includes(searchTerm))
        );
    });

    // Mettre à jour le tableau et le compteur
    populateAllAleasTable(filteredAleas);
    document.getElementById('all-aleas-count').textContent = filteredAleas.length + ' aléa' + (filteredAleas.length > 1 ? 's' : '');
}

/**
 * Réinitialiser la modale de tous les aléas
 */
function resetAllAleasModal() {
    document.getElementById('all-aleas-table-body').innerHTML = '';
    document.getElementById('all-aleas-count').textContent = '0 aléa';
    document.getElementById('all-aleas-filters-info').textContent = '';
    document.getElementById('all-aleas-search').value = '';

    // Réinitialiser les données stockées
    window.allAleasData = null;
}

/**
 * Remplir le tableau de tous les aléas
 */
function populateAllAleasTable(aleas) {
    const tbody = document.getElementById('all-aleas-table-body');
    tbody.innerHTML = '';

    aleas.forEach(function (alea) {
        const tr = document.createElement('tr');

        // Déterminer la classe pour le type d'aléa
        let typeBadgeClass = 'bg-secondary';
        switch (alea.typeAlea) {
            case 'Qualité':
                typeBadgeClass = 'bg-primary';
                break;
            case 'Prépa':
                typeBadgeClass = 'bg-info';
                break;
            case 'Maintenance':
                typeBadgeClass = 'bg-warning text-dark';
                break;
            case 'Formation':
                typeBadgeClass = 'bg-success';
                break;
            case 'Réunion':
                typeBadgeClass = 'bg-danger';
                break;
        }

        // Formater le commentaire (affecter une longueur maximale avec ellipsis)
        let commentaire = alea.commentaire || '';
        const commentaireComplet = commentaire;
        let commentaireAffiche = commentaire;

        if (commentaire.length > 50) {
            commentaireAffiche = commentaire.substring(0, 47) + '...';
        }

        tr.innerHTML = `
        <td>${alea.date}</td>
        <td>${alea.operateur || '-'}</td>
        <td>${alea.equipe || '-'}</td>
        <td>${alea.poste || '-'}</td>
        <td><span class="badge ${typeBadgeClass}">${alea.typeAlea || 'Non spécifié'}</span></td>
        <td>${alea.duree || '-'}</td>
        <td>${commentaireAffiche ? `<span title="${commentaireComplet}">${commentaireAffiche}</span>` : '-'}</td>
      `;

        tbody.appendChild(tr);
    });

    // Ajouter un gestionnaire d'événement pour exporter les aléas
    document.getElementById('btn-export-all-aleas').onclick = function () {
        exportAleasToCSV(aleas, 'tous');
    };
}
// Variables pour la pagination des aléas de l'opérateur
let operateurAleasData = [];
let filteredOperateurAleasData = [];
let currentOperateurAleasPage = 1;
const operateurAleasPerPage = 10;

/**
 * Fonction pour charger les aléas d'un opérateur dans la vue détaillée
 */
function loadOperateurDetail() {
    const operateurSelect = document.getElementById('operateur-select');
    const selectedOperateur = operateurSelect.value;

    if (!selectedOperateur) {
        alert("Veuillez sélectionner un opérateur");
        return;
    }

    // Afficher le loader
    document.getElementById('loader').style.display = 'block';
    document.getElementById('main-content').style.display = 'none';

    // Récupérer les données de l'opérateur
    google.script.run
        .withSuccessHandler(function (response) {
            console.log("Détail de l'opérateur reçu");
            detailOperateur = response;

            // Afficher l'onglet de détail
            // Utiliser le SA pour l'affichage si disponible
            const displayName = detailOperateur.operateur;
            document.getElementById('operateur-name').textContent = displayName;

            // Afficher aussi le SA si disponible
            if (detailOperateur.sa) {
                document.getElementById('operateur-name').textContent += ` (SA: ${detailOperateur.sa})`;
            }

            // Cacher le loader
            document.getElementById('loader').style.display = 'none';
            document.getElementById('main-content').style.display = 'block';

            // Basculer vers l'onglet de détail
            document.querySelectorAll('.tab-pane').forEach(tabPane => {
                tabPane.classList.remove('show', 'active');
            });

            document.querySelectorAll('.nav-link').forEach(navLink => {
                navLink.classList.remove('active');
            });

            // Afficher l'onglet de détail d'opérateur
            const tabDetail = document.getElementById('operateur-detail');
            tabDetail.classList.add('show', 'active');

            // Mettre à jour les visualisations de l'opérateur
            updateOperateurDetailUI();

            // Charger les aléas de l'opérateur
            loadOperateurAleas(detailOperateur.operateur);

            // Charger également les durées d'aléas par période pour cet opérateur
            google.script.run
                .withSuccessHandler(function (dureesResponse) {
                    if (dureesResponse.success) {
                        // Initialiser l'objet global si nécessaire
                        if (!window.operateurDureesAleasPeriodes) {
                            window.operateurDureesAleasPeriodes = {};
                        }

                        // Stocker les durées d'aléas pour cet opérateur
                        window.operateurDureesAleasPeriodes[detailOperateur.operateur] = dureesResponse.durees;

                        // Mettre à jour le tableau des périodes avec les vraies données d'aléas
                        updateOperateurPeriodesTable();

                        // Calculer et afficher les sommes de TAI par poste
                        calculateAndDisplayTAISums();
                    } else {
                        console.error("Erreur lors du chargement des durées d'aléas par période:", dureesResponse.message);
                    }
                })
                .withFailureHandler(function (error) {
                    console.error("Erreur lors de l'appel à obtenirDureesAleasOperateurParPeriode:", error);

                    // En cas d'erreur, mettre quand même à jour l'interface avec les données disponibles
                    updateOperateurPeriodesTable();
                    calculateAndDisplayTAISums();
                })
                .obtenirDureesAleasOperateurParPeriode(detailOperateur.operateur, activeFilters);
        })
        .withFailureHandler(handleError)
        .obtenirDonneesOperateur(selectedOperateur, activeFilters);
}

/**
 * Fonction pour charger les aléas d'un opérateur
 * @param {string} operateur - Nom de l'opérateur
 */
function loadOperateurAleas(operateur) {
    // Réinitialiser et afficher le loader des aléas
    resetOperateurAleasUI();

    // Afficher le spinner de chargement
    document.getElementById('operateur-aleas-loading').style.display = 'block';
    document.getElementById('operateur-aleas-content').style.display = 'none';
    document.getElementById('operateur-aleas-error').style.display = 'none';
    document.getElementById('operateur-aleas-empty').style.display = 'none';

    // Récupérer les aléas avec les filtres actuels
    google.script.run
        .withSuccessHandler(function (response) {
            document.getElementById('operateur-aleas-loading').style.display = 'none';

            if (response.success) {
                if (response.aleas && response.aleas.length > 0) {
                    // Stocker les données
                    operateurAleasData = response.aleas;
                    filteredOperateurAleasData = [...operateurAleasData];
                    currentOperateurAleasPage = 1;

                    // Afficher les aléas
                    updateOperateurAleasUI();
                } else {
                    // Aucun aléa trouvé
                    document.getElementById('operateur-aleas-empty').style.display = 'block';
                }
            } else {
                // Erreur
                document.getElementById('operateur-aleas-error').textContent = response.message || "Une erreur est survenue lors du chargement des aléas.";
                document.getElementById('operateur-aleas-error').style.display = 'block';
            }
        })
        .withFailureHandler(function (error) {
            document.getElementById('operateur-aleas-loading').style.display = 'none';
            document.getElementById('operateur-aleas-error').textContent = "Erreur: " + error;
            document.getElementById('operateur-aleas-error').style.display = 'block';
        })
        .obtenirAleasOperateur(operateur, activeFilters);
}

/**
 * Réinitialiser l'interface des aléas de l'opérateur
 */
function resetOperateurAleasUI() {
    document.getElementById('operateur-aleas-table-body').innerHTML = '';
    document.getElementById('operateur-aleas-count').textContent = '0 aléa';
    document.getElementById('operateur-aleas-filters-info').textContent = '';
    document.getElementById('operateur-aleas-search').value = '';

    // Réinitialiser les données
    operateurAleasData = [];
    filteredOperateurAleasData = [];
    currentOperateurAleasPage = 1;
}

/**
 * Mettre à jour l'interface des aléas de l'opérateur
 */
function updateOperateurAleasUI() {
    // Afficher le contenu
    document.getElementById('operateur-aleas-content').style.display = 'block';

    // Mettre à jour le tableau
    populateOperateurAleasTable();

    // Mettre à jour le compteur
    document.getElementById('operateur-aleas-count').textContent = filteredOperateurAleasData.length + ' aléa' + (filteredOperateurAleasData.length > 1 ? 's' : '');

    // Mettre à jour les informations sur les filtres
    updateOperateurAleasFiltersInfo();

    // Ajouter l'écouteur d'événement pour l'exportation
    document.getElementById('btn-export-operateur-aleas').onclick = function () {
        exportAleasToCSV(filteredOperateurAleasData, document.getElementById('operateur-name').textContent);
    };

    // Initialiser les écouteurs si c'est la première fois
    initOperateurAleasListeners();
}

/**
 * Initialiser les écouteurs d'événements pour les aléas de l'opérateur
 */
function initOperateurAleasListeners() {
    // Vérifier si les écouteurs sont déjà initialisés
    if (!window.operateurAleasListenersInitialized) {
        // Écouteurs pour la pagination
        document.getElementById('operateur-btn-prev-page').addEventListener('click', function () {
            if (currentOperateurAleasPage > 1) {
                currentOperateurAleasPage--;
                populateOperateurAleasTable();
                updateOperateurAleasPaginationButtons();
            }
        });

        document.getElementById('operateur-btn-next-page').addEventListener('click', function () {
            const totalPages = Math.ceil(filteredOperateurAleasData.length / operateurAleasPerPage);
            if (currentOperateurAleasPage < totalPages) {
                currentOperateurAleasPage++;
                populateOperateurAleasTable();
                updateOperateurAleasPaginationButtons();
            }
        });

        // Écouteur pour la recherche
        document.getElementById('operateur-aleas-search').addEventListener('input', filterOperateurAleasTable);

        // Marquer comme initialisé
        window.operateurAleasListenersInitialized = true;
    }

    // Mettre à jour les boutons de pagination
    updateOperateurAleasPaginationButtons();
}

/**
 * Mettre à jour les informations sur les filtres pour les aléas de l'opérateur
 */
function updateOperateurAleasFiltersInfo() {
    // Afficher les informations sur les filtres
    if (activeFilters && (activeFilters.dateDebut || activeFilters.dateFin || activeFilters.poste || activeFilters.equipe)) {
        let filtersInfo = "Filtré par: ";
        let hasFilter = false;

        if (activeFilters.dateDebut && activeFilters.dateFin) {
            filtersInfo += "période du " + formatDate(activeFilters.dateDebut) + " au " + formatDate(activeFilters.dateFin);
            hasFilter = true;
        } else if (activeFilters.dateDebut) {
            filtersInfo += "date après " + formatDate(activeFilters.dateDebut);
            hasFilter = true;
        } else if (activeFilters.dateFin) {
            filtersInfo += "date avant " + formatDate(activeFilters.dateFin);
            hasFilter = true;
        }

        if (activeFilters.poste) {
            filtersInfo += (hasFilter ? ", " : "") + "poste '" + activeFilters.poste + "'";
            hasFilter = true;
        }

        if (activeFilters.equipe) {
            filtersInfo += (hasFilter ? ", " : "") + "équipe '" + activeFilters.equipe + "'";
        }

        document.getElementById('operateur-aleas-filters-info').textContent = filtersInfo;
    } else {
        document.getElementById('operateur-aleas-filters-info').textContent = "Aucun filtre appliqué";
    }
}

/**
 * Filtrer le tableau des aléas de l'opérateur selon le terme de recherche
 */
function filterOperateurAleasTable() {
    const searchTerm = document.getElementById('operateur-aleas-search').value.toLowerCase().trim();

    // Si aucun terme de recherche, utiliser les données complètes
    if (!searchTerm) {
        filteredOperateurAleasData = [...operateurAleasData];
    } else {
        // Filtrer les données
        filteredOperateurAleasData = operateurAleasData.filter(alea => {
            return (
                (alea.equipe && alea.equipe.toLowerCase().includes(searchTerm)) ||
                (alea.poste && alea.poste.toLowerCase().includes(searchTerm)) ||
                (alea.typeAlea && alea.typeAlea.toLowerCase().includes(searchTerm)) ||
                (alea.commentaire && alea.commentaire.toLowerCase().includes(searchTerm))
            );
        });
    }

    // Réinitialiser la pagination
    currentOperateurAleasPage = 1;

    // Mettre à jour l'affichage
    populateOperateurAleasTable();

    // Mettre à jour le compteur
    document.getElementById('operateur-aleas-count').textContent = filteredOperateurAleasData.length + ' aléa' + (filteredOperateurAleasData.length > 1 ? 's' : '');

    // Mettre à jour les boutons de pagination
    updateOperateurAleasPaginationButtons();
}

/**
 * Remplir le tableau des aléas de l'opérateur
 */
function populateOperateurAleasTable() {
    const tbody = document.getElementById('operateur-aleas-table-body');
    tbody.innerHTML = '';

    // Calculer les indices de début et de fin pour la pagination
    const start = (currentOperateurAleasPage - 1) * operateurAleasPerPage;
    const end = Math.min(start + operateurAleasPerPage, filteredOperateurAleasData.length);

    // Mettre à jour l'information de pagination
    document.getElementById('operateur-aleas-pagination-info').textContent = `Affichage de ${start + 1}-${end} sur ${filteredOperateurAleasData.length}`;

    // N'afficher que les aléas de la page actuelle
    const pageData = filteredOperateurAleasData.slice(start, end);

    pageData.forEach(function (alea) {
        const tr = document.createElement('tr');

        // Déterminer la classe pour le type d'aléa
        let typeBadgeClass = 'bg-secondary';
        switch (alea.typeAlea) {
            case 'Qualité':
                typeBadgeClass = 'bg-primary';
                break;
            case 'Prépa':
                typeBadgeClass = 'bg-info';
                break;
            case 'Maintenance':
                typeBadgeClass = 'bg-warning text-dark';
                break;
            case 'Formation':
                typeBadgeClass = 'bg-success';
                break;
            case 'Réunion':
                typeBadgeClass = 'bg-danger';
                break;
        }

        // Formater le commentaire (affecter une longueur maximale avec ellipsis)
        let commentaire = alea.commentaire || '';
        const commentaireComplet = commentaire;
        let commentaireAffiche = commentaire;

        if (commentaire.length > 50) {
            commentaireAffiche = commentaire.substring(0, 47) + '...';
        }

        tr.innerHTML = `
        <td>${alea.date}</td>
        <td><span class="badge ${typeBadgeClass}">${alea.typeAlea || 'Non spécifié'}</span></td>
        <td>${alea.poste || '-'}</td>
        <td>${alea.equipe || '-'}</td>
        <td>${alea.duree || '-'}</td>
        <td>${commentaireAffiche ? `<span title="${commentaireComplet}">${commentaireAffiche}</span>` : '-'}</td>
      `;

        tbody.appendChild(tr);
    });
}
// Fonctions pour intégrer les informations d'aléas dans le tableau de bord

/**
 * Charge les données d'aléas pour tous les tableaux
 * Cette fonction doit être appelée après que les données principales sont chargées
 */
function loadAleasDurations() {
    // Afficher un message de chargement
    updateLoaderMessage("Chargement des aléas...");

    // 1. Charger les durées d'aléas par opérateur pour le tableau des opérateurs
    loadDureesAleasOperateurs();

    // 2. Charger les durées d'aléas par poste pour le tableau des postes
    loadDureesAleasPostes();

    // 3. Charger les durées d'aléas par équipe pour le tableau des équipes
    loadDureesAleasEquipes();

    // 4. Charger les durées d'aléas par période pour le tableau d'évolution
    loadDureesAleasPeriodes();
}

// Variables globales pour stocker les durées d'aléas
let dureesAleasOperateurs = {};
let dureesAleasPostes = [];
let dureesAleasEquipes = [];
let dureesAleasPeriodes = {};


/**
 * Charge les durées d'aléas par opérateur
 */
function loadDureesAleasOperateurs() {
    google.script.run
        .withSuccessHandler(function (response) {
            if (response.success) {
                dureesAleasOperateurs = response.durees;

                // Si le tableau des opérateurs est déjà affiché, mettre à jour
                if (statsOperateurs && statsOperateurs.length > 0) {
                    updateOperateursTable(null, document.querySelector('input[name="poste-filter"]:checked')?.value || 'all');
                }
            } else {
                console.error("Erreur lors du chargement des durées d'aléas par opérateur:", response.message);
            }
        })
        .withFailureHandler(function (error) {
            console.error("Erreur lors de l'appel à obtenirDureesAleasParOperateur:", error);
        })
        .obtenirDureesAleasParOperateur(statsOperateurs.map(op => op.operateur), activeFilters);
}

/**
 * Charge les durées d'aléas par poste
 */
function loadDureesAleasPostes() {
    google.script.run
        .withSuccessHandler(function (response) {
            if (response.success) {
                dureesAleasPostes = response.durees;

                // Si le tableau des postes est déjà affiché, mettre à jour
                if (statsPostes && statsPostes.length > 0) {
                    updatePostesSection();
                }
            } else {
                console.error("Erreur lors du chargement des durées d'aléas par poste:", response.message);
            }
        })
        .withFailureHandler(function (error) {
            console.error("Erreur lors de l'appel à obtenirDureesAleasParPoste:", error);
        })
        .obtenirDureesAleasParPoste(activeFilters);
}

/**
 * Charge les durées d'aléas par équipe
 */
function loadDureesAleasEquipes() {
    google.script.run
        .withSuccessHandler(function (response) {
            if (response.success) {
                dureesAleasEquipes = response.durees;

                // Si le tableau des équipes est déjà affiché, mettre à jour
                if (statsEquipes && statsEquipes.length > 0) {
                    updateEquipesSection();
                }
            } else {
                console.error("Erreur lors du chargement des durées d'aléas par équipe:", response.message);
            }
        })
        .withFailureHandler(function (error) {
            console.error("Erreur lors de l'appel à obtenirDureesAleasParEquipe:", error);
        })
        .obtenirDureesAleasParEquipe(activeFilters);
}

/**
 * Charge les durées d'aléas par période (pour le tableau d'évolution)
 */
function loadDureesAleasPeriodes() {
    // Déterminer le type de période actuellement sélectionné
    const periodeType = document.querySelector('input[name="periode-type"]:checked').value;

    google.script.run
        .withSuccessHandler(function (response) {
            if (response.success) {
                // Organiser les données par période
                dureesAleasPeriodes[periodeType] = {};
                response.durees.forEach(item => {
                    dureesAleasPeriodes[periodeType][item.periode] = item.duree;
                });

                // Mettre à jour le tableau d'évolution
                if (statsTemporelles && statsTemporelles[periodeType]) {
                    updateEvolutionData();
                }
            } else {
                console.error(`Erreur lors du chargement des durées d'aléas par ${periodeType}:`, response.message);
            }
        })
        .withFailureHandler(function (error) {
            console.error(`Erreur lors de l'appel à obtenirDureesAleasParPeriode pour ${periodeType}:`, error);
        })
        .obtenirDureesAleasParPeriode(periodeType, activeFilters);
}
/**
 * Mettre à jour les boutons de pagination pour les aléas de l'opérateur
 */
function updateOperateurAleasPaginationButtons() {
    const totalPages = Math.ceil(filteredOperateurAleasData.length / operateurAleasPerPage);

    // Activer/désactiver les boutons de pagination
    document.getElementById('operateur-btn-prev-page').disabled = currentOperateurAleasPage <= 1;
    document.getElementById('operateur-btn-next-page').disabled = currentOperateurAleasPage >= totalPages;
}

function updateTableHeaders() {
    // 1. Tableau Détail par poste
    const theadPostes = document.getElementById('table-postes').querySelector('thead tr');
    if (theadPostes) {
        const headersPostes = theadPostes.querySelectorAll('th');
        if (headersPostes.length >= 5 && headersPostes[4].textContent === "Entrées") {
            headersPostes[4].textContent = "Durée aléas (h)";
        }
    }

    // 2. Tableau Détail par équipe
    const theadEquipes = document.getElementById('table-equipes').querySelector('thead tr');
    if (theadEquipes) {
        const headersEquipes = theadEquipes.querySelectorAll('th');
        if (headersEquipes.length >= 5 && headersEquipes[4].textContent === "Entrées") {
            headersEquipes[4].textContent = "Durée aléas (h)";
        }
    }

    // 3. Tableau Classement des opérateurs
    const theadOperateurs = document.getElementById('table-operateurs').querySelector('thead tr');
    if (theadOperateurs) {
        const headersOperateurs = theadOperateurs.querySelectorAll('th');
        if (headersOperateurs.length >= 6 && headersOperateurs[5].textContent === "Entrées") {
            headersOperateurs[5].textContent = "Durée aléas (h)";
        }
    }

    // 4. Tableau Détail par période (dans la vue détaillée d'un opérateur)
    const theadOperateurPeriodes = document.getElementById('table-operateur-periodes')?.querySelector('thead tr');
    if (theadOperateurPeriodes) {
        const headersOperateurPeriodes = theadOperateurPeriodes.querySelectorAll('th');
        if (headersOperateurPeriodes.length >= 3 && headersOperateurPeriodes[2].textContent === "Entrées") {
            headersOperateurPeriodes[2].textContent = "Durée aléas (h)";
        }
    }

    // 5. Tableau d'évolution
    const theadEvolution = document.getElementById('table-evolution').querySelector('thead tr');
    if (theadEvolution) {
        const headersEvolution = theadEvolution.querySelectorAll('th');
        if (headersEvolution.length >= 3 && headersEvolution[2].textContent === "Entrées") {
            headersEvolution[2].textContent = "Durée aléas (h)";
        }
    }
}

/**
 * Mise à jour de l'interface
 */
// Remplacer la fonction updateUI() par celle-ci :
function updateUI() {
    // Vérifier les données minimales nécessaires sont chargées
    if (!statsPostes || !statsEquipes || !statsOperateurs || !statsTemporelles) {
        console.log("Données principales manquantes, attente...");
        return;
    }
    
    console.log("Mise à jour de l'interface avec données disponibles");

    // Initialiser statsInactivite s'il n'existe pas pour éviter le blocage
    if (!statsInactivite) {
        statsInactivite = { total: { duree: 0, nbEntrees: 0 } };
    }

    // Continuer avec les fonctions de mise à jour même si certaines données secondaires manquent
    updateOverviewSection();
    updateTableHeaders();
    updatePostesSection();
    updateEquipesSection();
    updateEvolutionData();
    updateOperateursSection();
    
    // Mettre à jour l'inactivité seulement si les données sont disponibles
    if (statsInactivite && statsInactivite.total !== undefined) {
        try {
            updateInactiviteTab();
        } catch (err) {
            console.error("Erreur lors de la mise à jour de l'onglet inactivité:", err);
        }
    }
    
    try {
        calculateAndDisplayTAISums();
    } catch (err) {
        console.error("Erreur lors du calcul des sommes TAI:", err);
    }

    // Cacher le loader et afficher le contenu
    document.getElementById('loader').style.display = 'none';
    document.getElementById('main-content').style.display = 'block';
}

// ==========================================
// == Fonctions pour l'Onglet INACTIVITE ==
// ==========================================

// Fonction principale pour mettre à jour l'onglet Inactivité
function updateInactiviteTab() {
  console.log("Mise à jour de l'onglet Inactivité");
  
  // Vérifier si des données valides existent
  if (!statsInactivite || !statsInactivite.total) {
    console.log("Aucune donnée d'inactivité à afficher.");
    document.getElementById('inactivite-empty').style.display = 'block';
    document.getElementById('inactivite-content').style.display = 'none';
    return;
  }
  
  // Mettre à jour les indicateurs
  updateInactiviteIndicators();
  
  // Mettre à jour les graphiques et tableaux
  createInactiviteTypeChart();
  updateInactiviteTypesTable();
  createInactivitePostesChart();
  createInactiviteEquipesChart();
  updateInactiviteEvolutionChart();
  
  // Initialiser les écouteurs d'événements si ce n'est pas déjà fait
  initInactiviteTabListeners();
  
  // Afficher le contenu
  document.getElementById('inactivite-content').style.display = 'block';
}

// Initialiser les listeners (bouton refresh, changement de période évolution)
function initInactiviteTabListeners() {
  // Vérifier que les écouteurs d'événements ne sont pas déjà ajoutés
  if (window.inactiviteListenersInitialized) return;
  
  // Ajouter l'écouteur pour le bouton de rafraîchissement
  const refreshButton = document.getElementById('btn-refresh-inactivite');
  if (refreshButton) {
    refreshButton.addEventListener('click', loadInactiviteStats);
  }
  
  // Ajouter les écouteurs pour les boutons de type de période
  document.querySelectorAll('input[name="inactivite-periode-type"]').forEach(input => {
    input.addEventListener('change', updateInactiviteEvolutionChart);
  });
  
  // Marquer les écouteurs comme initialisés
  window.inactiviteListenersInitialized = true;
}



// Mettre à jour le tableau détaillé par type
function updateInactiviteTypesTable() {
  console.log("Mise à jour du tableau des types d'inactivité");
  
  const tbody = document.getElementById('table-inactivite-types-body');
  if (!tbody) {
    console.error("Élément 'table-inactivite-types-body' introuvable");
    return;
  }
  
  // Vider le tableau
  tbody.innerHTML = '';
  
  // Vérifier que nous avons des données
  if (!statsInactivite.parType || Object.keys(statsInactivite.parType).length === 0) {
    const tr = document.createElement('tr');
    tr.innerHTML = '<td colspan="5" class="text-center">Aucune donnée disponible</td>';
    tbody.appendChild(tr);
    return;
  }
  
  // Calculer le total global d'inactivité
  const totalDuree = Object.values(statsInactivite.parType).reduce(
    (sum, data) => sum + (data.duree || 0), 0
  );
  
  // Créer un tableau pour trier les données
  const typeData = Object.entries(statsInactivite.parType).map(([type, data]) => ({
    type: type,
    duree: data.duree || 0,
    occurrences: data.nbOccurrences || 0,
    pourcentage: totalDuree > 0 ? ((data.duree || 0) / totalDuree) * 100 : 0,
    moyenne: data.nbOccurrences > 0 ? (data.duree || 0) / data.nbOccurrences : 0
  }));
  
  // Trier par durée décroissante
  typeData.sort((a, b) => b.duree - a.duree);
  
  // Ajouter chaque type au tableau
  typeData.forEach(data => {
    // Déterminer la classe de la ligne en fonction du pourcentage
    let rowClass = '';
    if (data.pourcentage > 30) {
      rowClass = 'table-danger';
    } else if (data.pourcentage > 15) {
      rowClass = 'table-warning';
    } else {
      rowClass = 'table-success';
    }
    
    const tr = document.createElement('tr');
    tr.className = rowClass;
    
    tr.innerHTML = `
      <td><strong>${data.type}</strong></td>
      <td>${data.duree.toFixed(2)}</td>
      <td>${data.pourcentage.toFixed(1)}%</td>
      <td>${data.occurrences}</td>
      <td>${data.moyenne.toFixed(2)}</td>
    `;
    
    tbody.appendChild(tr);
  });
}

// Fonction pour créer le graphique Pareto
function createInactiviteParetoChart() {
    const ctx = document.getElementById('chart-inactivite-pareto')?.getContext('2d');
    if (!ctx) return;
    destroyChartIfExists(inactiviteParetoChart); inactiviteParetoChart = null;
    if (!statsInactivite.parType) return;

    const sortedTypes = Object.entries(statsInactivite.parType)
                             .filter(([, data]) => data.duree > 0)
                             .sort(([, a], [, b]) => b.duree - a.duree);

    if (sortedTypes.length === 0) return;

    const labels = sortedTypes.map(([type]) => type);
    const durees = sortedTypes.map(([, data]) => data.duree);

    const totalDuree = durees.reduce((a, b) => a + b, 0);
    if(totalDuree === 0) return; // Éviter division par zéro

    let cumulativePercent = 0;
    const cumulativeData = durees.map(duree => {
        cumulativePercent += (duree / totalDuree) * 100;
        // S'assurer que le cumul ne dépasse pas 100% à cause des arrondis
        return Math.min(cumulativePercent, 100);
    });

    const colors = generateColors(labels.length);

    inactiviteParetoChart = new Chart(ctx, {
         type: 'bar',
         data: {
             labels: labels,
             datasets: [{
                 label: 'Durée Inactivité (h)',
                 data: durees,
                 backgroundColor: colors,
                 borderColor: colors.map(c => c.replace('0.7', '1')),
                 borderWidth: 1,
                 borderRadius: 4,
                 order: 1,
                 yAxisID: 'y',
             }, {
                 label: 'Cumul %',
                 data: cumulativeData,
                 type: 'line',
                 borderColor: 'rgba(255, 99, 132, 1)',
                 backgroundColor: 'transparent',
                 borderWidth: 2,
                 pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                 pointRadius: 3,
                 tension: 0.1,
                 yAxisID: 'percentage',
                 order: 0
             }]
         },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
               tooltip: {
                   mode: 'index',
                   intersect: false,
                   callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.parsed.y !== null) {
                                if (context.dataset.label === 'Cumul %') {
                                    label += context.parsed.y.toFixed(1) + '%';
                                } else {
                                     label += context.parsed.y.toFixed(2) + ' h';
                                }
                            }
                            return label;
                        }
                   }
               },
               legend: { position: 'top' }
            },
            scales: {
                 x: { grid: { display: false }, ticks: { autoSkip: false, maxRotation: 45, minRotation: 45 } }, // Rotation pour noms longs
                 y: {
                     beginAtZero: true,
                     title: { display: true, text: 'Durée (h)'},
                     grid: { color: '#e9ecef' }
                 },
                 percentage: {
                    position: 'right',
                    beginAtZero: true,
                    min: 0,
                    max: 105, // Laisser un peu d'espace
                    title: { display: true, text: 'Cumul %' },
                    grid: { display: false },
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

// Fonction pour créer le graphique par postes
function createInactivitePostesChart() {
  console.log("Création du graphique des postes par inactivité");
  
  const canvas = document.getElementById('chart-inactivite-postes');
  if (!canvas) {
    console.error("Élément canvas 'chart-inactivite-postes' introuvable");
    return;
  }
  
  // Détruire le graphique existant s'il y en a un
  if (window.inactivitePostesChart) {
    window.inactivitePostesChart.destroy();
  }
  
  // Vérifier que nous avons des données par poste
  if (!statsInactivite.parPoste || Object.keys(statsInactivite.parPoste).length === 0) {
    console.warn("Pas de données par poste disponibles");
    return;
  }
  
  // Créer un tableau pour trier les données
  const posteData = Object.entries(statsInactivite.parPoste).map(([poste, data]) => ({
    poste: poste,
    duree: data.duree || 0,
    entrees: data.nbEntrees || 0
  }));
  
  // Trier par durée décroissante et prendre les 10 premiers
  posteData.sort((a, b) => b.duree - a.duree);
  const topPostes = posteData.slice(0, 10);
  
  // Préparation des données
  const labels = topPostes.map(item => item.poste);
  const durees = topPostes.map(item => item.duree);
  
  // Générer des couleurs
  const colors = labels.map((_, index) => {
    const hue = (index * 360 / labels.length) % 360;
    return `hsla(${hue}, 70%, 60%, 0.7)`;
  });
  
  // Création du graphique
  window.inactivitePostesChart = new Chart(canvas.getContext('2d'), {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [{
        label: "Heures d'inactivité",
        data: durees,
        backgroundColor: colors,
        borderWidth: 0,
        borderRadius: 6,
        maxBarThickness: 50
      }]
    },
    options: {
      indexAxis: 'y',
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          display: false
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              return `Durée: ${context.raw.toFixed(2)} h`;
            },
            afterLabel: function(context) {
              const poste = topPostes[context.dataIndex];
              return `Nombre d'entrées: ${poste.entrees}`;
            }
          }
        }
      },
      scales: {
        x: {
          beginAtZero: true,
          title: {
            display: true,
            text: 'Heures d\'inactivité'
          }
        },
        y: {
          grid: {
            display: false
          }
        }
      }
    }
  });
}

// Fonction pour créer le graphique par équipes
function createInactiviteEquipesChart() {
  console.log("Création du graphique des équipes par inactivité");
  
  const canvas = document.getElementById('chart-inactivite-equipes');
  if (!canvas) {
    console.error("Élément canvas 'chart-inactivite-equipes' introuvable");
    return;
  }
  
  // Détruire le graphique existant s'il y en a un
  if (window.inactiviteEquipesChart) {
    window.inactiviteEquipesChart.destroy();
  }
  
  // Vérifier que nous avons des données par équipe
  if (!statsInactivite.parEquipe || Object.keys(statsInactivite.parEquipe).length === 0) {
    console.warn("Pas de données par équipe disponibles");
    return;
  }
  
  // Créer un tableau pour trier les données
  const equipeData = Object.entries(statsInactivite.parEquipe).map(([equipe, data]) => ({
    equipe: equipe,
    duree: data.duree || 0,
    entrees: data.nbEntrees || 0
  }));
  
  // Trier par durée décroissante
  equipeData.sort((a, b) => b.duree - a.duree);
  
  // Préparation des données
  const labels = equipeData.map(item => item.equipe);
  const durees = equipeData.map(item => item.duree);
  
  // Générer des couleurs
  const colors = labels.map((_, index) => {
    const hue = (index * 360 / labels.length + 120) % 360; // Décalage pour différencier des postes
    return `hsla(${hue}, 70%, 60%, 0.7)`;
  });
  
  // Création du graphique
  window.inactiviteEquipesChart = new Chart(canvas.getContext('2d'), {
    type: 'doughnut',
    data: {
      labels: labels,
      datasets: [{
        label: "Heures d'inactivité",
        data: durees,
        backgroundColor: colors,
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: {
          position: 'right',
          labels: {
            boxWidth: 12,
            padding: 10
          }
        },
        tooltip: {
          callbacks: {
            label: function(context) {
              const label = context.label || '';
              const value = context.raw || 0;
              const total = context.dataset.data.reduce((a, b) => a + b, 0);
              const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : '0.0';
              return `${label}: ${value.toFixed(2)}h (${percentage}%)`;
            },
            afterLabel: function(context) {
              const equipe = equipeData[context.dataIndex];
              return `Nombre d'entrées: ${equipe.entrees}`;
            }
          }
        }
      }
    }
  });
}

// Fonction pour mettre à jour le graphique d'évolution
function updateInactiviteEvolutionChart() {
  console.log("Mise à jour du graphique d'évolution de l'inactivité");
  
  const canvas = document.getElementById('chart-inactivite-evolution');
  if (!canvas) {
    console.error("Élément canvas 'chart-inactivite-evolution' introuvable");
    return;
  }
  
  // Détruire le graphique existant s'il y en a un
  if (window.inactiviteEvolutionChart) {
    window.inactiviteEvolutionChart.destroy();
  }
  
  // Vérifier que nous avons des données
  if (!statsInactivite.total) {
    console.warn("Pas de données disponibles pour le graphique d'évolution");
    return;
  }
  
  // Récupérer le type de période sélectionné
  const periodeType = document.querySelector('input[name="inactivite-periode-type"]:checked')?.value || 'mois';
  
  // Agréger les données par période
  const donneesParPeriode = {};
  
  // Parcourir les données (si nous avons des données détaillées par période)
  if (statsInactivite.donnees && Array.isArray(statsInactivite.donnees)) {
    statsInactivite.donnees.forEach(item => {
      if (!item.date) return;
      
      // Convertir la date en objet Date si ce n'est pas déjà le cas
      let date;
      if (item.date instanceof Date) {
        date = item.date;
      } else {
        // Si c'est une string, essayer de la parser
        date = new Date(item.date);
        if (isNaN(date.getTime())) {
          // Essayer le format DD/MM/YYYY
          const parts = item.date.split('/');
          if (parts.length === 3) {
            date = new Date(parts[2], parts[1] - 1, parts[0]);
          } else {
            return; // Date invalide
          }
        }
      }
      
      // Déterminer la période
      let periode;
      if (periodeType === 'mois') {
        periode = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      } else {
        // Calculer la semaine de l'année
        const premierJanvier = new Date(date.getFullYear(), 0, 1);
        const jours = Math.floor((date - premierJanvier) / (24 * 60 * 60 * 1000));
        const semaine = Math.ceil((jours + premierJanvier.getDay() + 1) / 7);
        periode = `${date.getFullYear()}-S${String(semaine).padStart(2, '0')}`;
      }
      
      // Initialiser la période si nécessaire
      if (!donneesParPeriode[periode]) {
        donneesParPeriode[periode] = {
          inactiviteTotal: 0,
          nbEntrees: 0
        };
      }
      
      // Ajouter l'inactivité
      if (item.inactiviteTotal !== undefined) {
        donneesParPeriode[periode].inactiviteTotal += item.inactiviteTotal;
        donneesParPeriode[periode].nbEntrees++;
      }
    });
  }
  
  // Si nous n'avons pas de données détaillées, utiliser les données agrégées par période si disponibles
  if (Object.keys(donneesParPeriode).length === 0 && statsInactivite.parPeriode) {
    const periodeData = statsInactivite.parPeriode[periodeType] || [];
    
    if (Array.isArray(periodeData)) {
      periodeData.forEach(item => {
        if (item.periode && item.duree !== undefined) {
          donneesParPeriode[item.periode] = {
            inactiviteTotal: item.duree,
            nbEntrees: item.nbEntrees || 1
          };
        }
      });
    }
  }
  
  // Si toujours aucune donnée, générer des données de simulation pour la démo
  if (Object.keys(donneesParPeriode).length === 0) {
    console.log("Pas de données d'évolution réelles, génération de données simulées");
    
    // Générer 6 périodes
    const today = new Date();
    for (let i = 0; i < 6; i++) {
      let date = new Date(today);
      date.setMonth(today.getMonth() - i);
      
      const periode = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
      
      donneesParPeriode[periode] = {
        inactiviteTotal: Math.random() * 20 + 5, // Entre 5 et 25 heures
        nbEntrees: Math.floor(Math.random() * 10 + 5) // Entre 5 et 15 entrées
      };
    }
  }
  
  // Convertir en tableaux pour le graphique
  const periodes = Object.keys(donneesParPeriode).sort();
  const inactiviteValues = periodes.map(p => donneesParPeriode[p].inactiviteTotal);
  const nbEntrees = periodes.map(p => donneesParPeriode[p].nbEntrees);
  
  // Formater les étiquettes selon le type de période
  const labels = periodes.map(periode => {
    if (periodeType === 'mois') {
      const [annee, mois] = periode.split('-');
      const moisNoms = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sep', 'Oct', 'Nov', 'Déc'];
      return `${moisNoms[parseInt(mois) - 1]} ${annee}`;
    } else {
      return periode; // Format YYYY-SXX
    }
  });
  
  // Créer le graphique
  window.inactiviteEvolutionChart = new Chart(canvas.getContext('2d'), {
    type: 'bar',
    data: {
      labels: labels,
      datasets: [
        {
          label: "Heures d'inactivité",
          data: inactiviteValues,
          backgroundColor: 'rgba(54, 162, 235, 0.7)',
          borderColor: 'rgba(54, 162, 235, 1)',
          borderWidth: 1,
          borderRadius: 4,
          order: 1
        },
        {
          label: "Nombre d'entrées",
          data: nbEntrees,
          type: 'line',
          backgroundColor: 'transparent',
          borderColor: 'rgba(255, 99, 132, 1)',
          borderWidth: 2,
          pointRadius: 4,
          pointBackgroundColor: 'rgba(255, 99, 132, 1)',
          pointBorderColor: '#fff',
          tension: 0.1,
          yAxisID: 'y1',
          order: 0
        }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        title: {
          display: true,
          text: `Évolution de l'inactivité par ${periodeType === 'mois' ? 'mois' : 'semaine'}`,
          font: {
            size: 16,
            weight: 'bold'
          }
        },
        tooltip: {
          mode: 'index',
          callbacks: {
            label: function(context) {
              if (context.dataset.label === "Heures d'inactivité") {
                return `${context.dataset.label}: ${context.raw.toFixed(2)}h`;
              } else {
                return `${context.dataset.label}: ${context.raw}`;
              }
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: "Heures d'inactivité"
          }
        },
        y1: {
          position: 'right',
          beginAtZero: true,
          title: {
            display: true,
            text: "Nombre d'entrées"
          },
          grid: {
            display: false
          }
        },
        x: {
          grid: {
            display: false
          }
        }
      }
    }
  });
}


// Fonction utilitaire pour détruire un graphique Chart.js
function destroyChartIfExists(chartInstance) {
    if (chartInstance && typeof chartInstance.destroy === 'function') {
        chartInstance.destroy();
    }
}

// Fonction utilitaire pour générer des couleurs
function generateColors(count, hueOffset = 0, saturation = 70, lightness = 60, alpha = 0.7) {
    const colors = [];
    if (count <= 0) return colors; // Gérer le cas où count est 0 ou négatif
    const step = 360 / count;
    for (let i = 0; i < count; i++) {
        const hue = (hueOffset + (i * step)) % 360;
        colors.push(`hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`);
    }
    return colors;
}

// Fonction utilitaire pour définir le contenu textuel d'un élément
function setTextContent(elementId, text) {
    const element = document.getElementById(elementId);
    if (element) {
        element.textContent = text;
    } else {
        console.warn(`Élément avec ID '${elementId}' non trouvé.`);
    }
}

function updateOverviewSection() {
    // Code existant inchangé
    
    // Calculer les totaux globaux
    let totalTAI = 0, totalPresence = 0, count = 0;

    statsPostes.forEach(stat => {
        // On utilise directement les totaux fournis par le backend
        if ('taiTotal' in stat && 'presenceTotal' in stat) {
            totalTAI += stat.taiTotal;
            totalPresence += stat.presenceTotal;
        } else {
            // Fallback pour la compatibilité avec l'ancien format
            totalTAI += stat.taiMoyen * stat.nbEntrees;
            totalPresence += stat.presenceMoyen * stat.nbEntrees;
        }
        count += stat.nbEntrees;
    });

    // Calcul du rendement global comme la somme des TAI divisée par la somme des présences
    const rdtMoyenGlobal = totalPresence > 0 ? (totalTAI / totalPresence).toFixed(4) : "0";

    // Mettre à jour les indicateurs - afficher les totaux au lieu des moyennes
    document.getElementById('rendement-global').textContent = rdtMoyenGlobal;
    document.getElementById('tai-global').textContent = totalTAI.toFixed(2);
    document.getElementById('presence-globale').textContent = totalPresence.toFixed(2);

    // Mettre à jour les labels pour indiquer qu'il s'agit maintenant de totaux
    document.querySelector('#tai-global').nextElementSibling.textContent = "TAI total";
    document.querySelector('#presence-globale').nextElementSibling.textContent = "Présence totale (h)";
    
    // Calculer et afficher le total des heures d'aléas
    let totalHeuresAleas = 0;
    
    // Vérifier si nous avons des données d'aléas disponibles
    if (aleasAnalysisData && aleasAnalysisData.length > 0) {
        // Sommer toutes les durées d'aléas
        aleasAnalysisData.forEach(alea => {
            if (alea.duree && !isNaN(parseFloat(alea.duree))) {
                totalHeuresAleas += parseFloat(alea.duree);
            }
        });
    } else if (dureesAleasOperateurs) {
        // Alternative: utiliser les données agrégées par opérateur
        Object.values(dureesAleasOperateurs).forEach(duree => {
            if (!isNaN(parseFloat(duree))) {
                totalHeuresAleas += parseFloat(duree);
            }
        });
    }
    
    // Afficher le total des heures d'aléas
    document.getElementById('aleas-total-heures').textContent = totalHeuresAleas.toFixed(2);
    
    // Calculer et afficher le total des heures d'inactivité (hors congés)
    let totalInactiviteHorsConges = 0;
    
    // Vérifier si nous avons des données d'inactivité disponibles
    if (statsInactivite && statsInactivite.total) {
        // Total d'inactivité
        const totalInactivite = statsInactivite.total.duree || 0;
        
        // Total des congés (si disponible dans les types d'inactivité)
        let totalConges = 0;
        if (statsInactivite.parType && statsInactivite.parType['CONGES']) {
            totalConges = statsInactivite.parType['CONGES'].duree || 0;
        }
        
        // Calculer le total hors congés
        totalInactiviteHorsConges = totalInactivite - totalConges;
    }
    
    // Afficher le total des heures d'inactivité hors congés
    document.getElementById('inactivite-total-heures').textContent = totalInactiviteHorsConges.toFixed(2);

    // Créer les graphiques
    createTopPostesChart();
    createEquipesOverviewChart();
    
    // Mettre à jour le graphique de comparaison
    updateComparisonChart();
}

// Variable globale pour stocker l'instance du graphique
let comparisonChart = null;

// Fonction pour créer ou mettre à jour le graphique de comparaison
function updateComparisonChart() {
  const ctx = document.getElementById('chart-comparaison-tai-aleas-inactivite').getContext('2d');
  
  // Récupérer les valeurs calculées
  let totalTAI = parseFloat(document.getElementById('tai-global').textContent) || 0;
  let totalHeuresAleas = parseFloat(document.getElementById('aleas-total-heures').textContent) || 0;
  let totalInactiviteHorsConges = parseFloat(document.getElementById('inactivite-total-heures').textContent) || 0;
  
  // Récupérer l'objectif défini par l'utilisateur
  let objectif = parseFloat(document.getElementById('objectif-valeur').value) || 100;
  
  // Calculer le total des trois valeurs (pour information seulement)
  const totalHeures = totalTAI + totalHeuresAleas + totalInactiviteHorsConges;
  
  // Calculer l'écart avec l'objectif (positif si en dessous de l'objectif, négatif si au-dessus)
  // Uniquement par rapport au TAI, pas le total empilé
  const ecartAvecObjectif = objectif - totalTAI;
  
  // Préparer les données
  const data = {
    labels: ['Production'],
    datasets: [
      {
        // TAI en bas (premier dans l'empilement)
        label: 'TAI Total',
        data: [totalTAI],
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        borderColor: 'rgba(54, 162, 235, 1)',
        borderWidth: 1,
        stack: 'Stack 0',
      },
      {
        // Aléas au milieu
        label: 'Heures aléas',
        data: [totalHeuresAleas],
        backgroundColor: 'rgba(255, 99, 132, 0.7)',
        borderColor: 'rgba(255, 99, 132, 1)',
        borderWidth: 1,
        stack: 'Stack 0',
      },
      {
        // Inactivité au-dessus
        label: 'Heures inactivité (hors congés)',
        data: [totalInactiviteHorsConges],
        backgroundColor: 'rgba(255, 206, 86, 0.7)',
        borderColor: 'rgba(255, 206, 86, 1)',
        borderWidth: 1,
        stack: 'Stack 0',
      }
      // L'objectif sera affiché uniquement comme une ligne, pas une barre
    ]
  };
  
  // Configuration du graphique
  const config = {
    type: 'bar',
    data: data,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          grid: {
            display: false
          }
        },
        y: {
          stacked: true, // Pour que les barres soient empilées
          beginAtZero: true,
          title: {
            display: true,
            text: 'Heures'
          },
          grid: {
            color: function(context) {
              if (context.tick.value === objectif) {
                return 'rgba(75, 192, 192, 0.8)'; // Ligne de référence de l'objectif en couleur
              }
              return 'rgba(0, 0, 0, 0.1)'; // Grille normale en gris clair
            },
            lineWidth: function(context) {
              if (context.tick.value === objectif) {
                return 2; // Ligne plus épaisse pour l'objectif
              }
              return 1; // Épaisseur normale pour la grille
            },
            z: 1 // Placer la grille au-dessus des barres
          }
        }
      },
      plugins: {
        // Configuration du tooltip
        tooltip: {
          callbacks: {
            label: function(context) {
              let label = context.dataset.label || '';
              
              if (label) {
                label += ': ' + (context.formattedValue || '0') + 'h';
                
                // Ajouter le pourcentage par rapport au total des trois valeurs
                const percentage = (context.raw / totalHeures * 100).toFixed(1);
                label += ` (${percentage}% du total)`;
                
                // Pour le TAI, ajouter des informations sur l'écart avec l'objectif
                if (label.includes('TAI Total')) {
                  const taiFraction = (totalTAI / objectif * 100).toFixed(1);
                  if (ecartAvecObjectif >= 0) {
                    label += ` | Reste ${ecartAvecObjectif.toFixed(2)}h pour atteindre l'objectif (${taiFraction}% atteint)`;
                  } else {
                    label += ` | Objectif dépassé de ${Math.abs(ecartAvecObjectif).toFixed(2)}h (${taiFraction}% atteint)`;
                  }
                }
              }
              
              return label;
            },
            // Ajouter un titre dans le tooltip avec le total
            afterTitle: function() {
              return `Total empilé: ${totalHeures.toFixed(2)}h`;
            }
          }
        },
        legend: {
          position: 'top'
        },
        title: {
          display: true,
          text: 'TAI / Aléas / Inactivité avec objectif TAI',
          font: {
            size: 16
          }
        }
      }
    }
  };
  
  // Détruire le graphique existant s'il y en a un
  if (comparisonChart) {
    comparisonChart.destroy();
  }
  
  // Créer le nouveau graphique
  comparisonChart = new Chart(ctx, config);
  
  // Ajouter une fonction directe pour dessiner la ligne d'objectif et la zone d'écart
  comparisonChart.options.animation.onComplete = function() {
    const ctx = comparisonChart.ctx;
    const yAxis = comparisonChart.scales.y;
    const xAxis = comparisonChart.scales.x;
    
    // Récupérer les positions pour dessiner
    const yPixelTAI = yAxis.getPixelForValue(totalTAI);
    const yPixelObjectif = yAxis.getPixelForValue(objectif);
    
    ctx.save();
    
    // Tracer une ligne horizontale pour l'objectif
    ctx.beginPath();
    ctx.moveTo(xAxis.left, yPixelObjectif);
    ctx.lineTo(xAxis.right, yPixelObjectif);
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(75, 192, 192, 1)';
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    
    // Dessiner la zone d'écart entre TAI et objectif
    if (Math.abs(ecartAvecObjectif) > 2) {
      ctx.fillStyle = ecartAvecObjectif >= 0 ? 'rgba(75, 192, 192, 0.2)' : 'rgba(255, 99, 132, 0.2)';
      
      // Calculer les dimensions de la zone
      const startY = yPixelTAI;
      const endY = yPixelObjectif;
      const rectX = xAxis.getPixelForValue(0) - 10; // Un peu à gauche de la barre
      const rectWidth = 20; // Largeur fixe pour ne pas couvrir la barre
      
      // Dessiner le rectangle
      ctx.fillRect(rectX, Math.min(startY, endY), rectWidth, Math.abs(startY - endY));
      
      // Dessiner une flèche ou un indicateur
      ctx.fillStyle = ecartAvecObjectif >= 0 ? 'rgba(75, 192, 192, 1)' : 'rgba(255, 99, 132, 1)';
      ctx.font = 'bold 12px Arial';
      ctx.textAlign = 'right';
      
      const ecartTexte = ecartAvecObjectif >= 0 
        ? `+${ecartAvecObjectif.toFixed(1)}h` 
        : `-${Math.abs(ecartAvecObjectif).toFixed(1)}h`;
      
      ctx.fillText(ecartTexte, rectX - 5, (startY + endY) / 2);
    }
    
    // Ajouter un texte "Objectif TAI: X"
    ctx.fillStyle = 'rgba(75, 192, 192, 1)';
    ctx.font = 'bold 12px Arial';
    ctx.textAlign = 'right';
    ctx.fillText('Objectif TAI: ' + objectif, xAxis.right - 5, yPixelObjectif - 5);
    
    ctx.restore();
  };
  
  // Mise à jour de l'affichage de l'écart
  const ecartBadge = document.getElementById('ecart-objectif-badge');
  if (ecartBadge) {
    // Déterminer la couleur du badge en fonction de l'écart
    let badgeClass = 'bg-primary';
    let ecartTexte = '';
    
    if (ecartAvecObjectif > 0) {
      // En dessous de l'objectif (bon)
      badgeClass = 'bg-success';
      ecartTexte = `TAI sous l'objectif: ${ecartAvecObjectif.toFixed(2)}h`;
    } else if (ecartAvecObjectif < 0) {
      // Au-dessus de l'objectif (mauvais)
      badgeClass = 'bg-danger';
      ecartTexte = `TAI au-dessus de l'objectif: ${Math.abs(ecartAvecObjectif).toFixed(2)}h`;
    } else {
      // Exactement à l'objectif
      badgeClass = 'bg-info';
      ecartTexte = `TAI = Objectif exactement`;
    }
    
    // Mettre à jour la classe et le texte du badge
    ecartBadge.className = `badge ${badgeClass}`;
    ecartBadge.textContent = ecartTexte;
  }
}


// Modification du tableau "Détail par poste"
function updatePostesSection() {
    // Créer le graphique
    createPostesPerformanceChart();

    // Mettre à jour le tableau
    const tbody = document.getElementById('table-postes').querySelector('tbody');
    tbody.innerHTML = '';

    // Mise à jour de l'en-tête pour refléter TAI total, Présence totale, et Durée aléas
    const thead = document.getElementById('table-postes').querySelector('thead tr');
    const headers = thead.querySelectorAll('th');
    if (headers.length >= 5) {
        if (headers[2].textContent === "TAI") {
            headers[2].textContent = "TAI Total";
        }
        if (headers[3].textContent === "Présence") {
            headers[3].textContent = "Présence Totale";
        }
        if (headers[4].textContent === "Entrées") {
            headers[4].textContent = "Durée aléas (h)";
        }
    }

    // Fonction pour obtenir la durée totale des aléas par poste
    function getDureeAleasByPoste(poste) {
        // Chercher dans les données réelles
        const posteAlea = dureesAleasPostes.find(p => p.poste === poste);
        return posteAlea ? posteAlea.duree.toFixed(2) : "0.00";
    }

    statsPostes.forEach(stat => {
        const tr = document.createElement('tr');

        // Déterminer le statut
        let statusClass, statusIcon, statusText;
        if (stat.rendementMoyen >= CONFIG.seuils.rendement.bon) {
            statusClass = 'badge-success';
            statusIcon = 'check-circle';
            statusText = 'Bon';
        } else if (stat.rendementMoyen >= CONFIG.seuils.rendement.moyen) {
            statusClass = 'badge-warning';
            statusIcon = 'exclamation-circle';
            statusText = 'Moyen';
        } else {
            statusClass = 'badge-danger';
            statusIcon = 'times-circle';
            statusText = 'Faible';
        }

        // Utiliser taiTotal et presenceTotal au lieu des moyennes
        const taiTotal = 'taiTotal' in stat ? stat.taiTotal : (stat.taiMoyen * stat.nbEntrees);
        const presenceTotal = 'presenceTotal' in stat ? stat.presenceTotal : (stat.presenceMoyen * stat.nbEntrees);

        // Récupérer la durée totale des aléas pour ce poste
        const dureeAleas = getDureeAleasByPoste(stat.poste);

        tr.innerHTML = `
        <td><strong>${stat.poste}</strong></td>
        <td>${stat.rendementMoyen.toFixed(4)}</td>
        <td>${taiTotal.toFixed(2)}</td>
        <td>${presenceTotal.toFixed(2)}</td>
        <td>${dureeAleas}</td>
        <td>
          <span class="badge ${statusClass}">
            <i class="fas fa-${statusIcon} me-1"></i> ${statusText}
          </span>
        </td>
      `;

        tbody.appendChild(tr);
    });
}

// Tableau détail par Equipe
function updateEquipesSection() {
    // Créer le graphique
    createEquipesPerformanceChart();

    // Mettre à jour le tableau
    const tbody = document.getElementById('table-equipes').querySelector('tbody');
    tbody.innerHTML = '';

    // Mise à jour de l'en-tête pour refléter TAI total, Présence totale, et Durée aléas
    const thead = document.getElementById('table-equipes').querySelector('thead tr');
    const headers = thead.querySelectorAll('th');
    if (headers.length >= 5) {
        if (headers[2].textContent === "TAI") {
            headers[2].textContent = "TAI Total";
        }
        if (headers[3].textContent === "Présence") {
            headers[3].textContent = "Présence Totale";
        }
        if (headers[4].textContent === "Entrées") {
            headers[4].textContent = "Durée aléas (h)";
        }
    }

    // Fonction pour obtenir la durée totale des aléas par équipe
    function getDureeAleasByEquipe(equipe) {
        // Chercher dans les données réelles
        const equipeAlea = dureesAleasEquipes.find(e => e.equipe === equipe);
        return equipeAlea ? equipeAlea.duree.toFixed(2) : "0.00";
    }

    statsEquipes.forEach(stat => {
        const tr = document.createElement('tr');

        // Déterminer le statut
        let statusClass, statusIcon, statusText;
        if (stat.rendementMoyen >= CONFIG.seuils.rendement.bon) {
            statusClass = 'badge-success';
            statusIcon = 'check-circle';
            statusText = 'Bon';
        } else if (stat.rendementMoyen >= CONFIG.seuils.rendement.moyen) {
            statusClass = 'badge-warning';
            statusIcon = 'exclamation-circle';
            statusText = 'Moyen';
        } else {
            statusClass = 'badge-danger';
            statusIcon = 'times-circle';
            statusText = 'Faible';
        }

        // Utiliser taiTotal et presenceTotal au lieu des moyennes
        const taiTotal = 'taiTotal' in stat ? stat.taiTotal : (stat.taiMoyen * stat.nbEntrees);
        const presenceTotal = 'presenceTotal' in stat ? stat.presenceTotal : (stat.presenceMoyen * stat.nbEntrees);

        // Récupérer la durée totale des aléas pour cette équipe
        const dureeAleas = getDureeAleasByEquipe(stat.equipe);

        tr.innerHTML = `
        <td><strong>${stat.equipe}</strong></td>
        <td>${stat.rendementMoyen.toFixed(4)}</td>
        <td>${taiTotal.toFixed(2)}</td>
        <td>${presenceTotal.toFixed(2)}</td>
        <td>${dureeAleas}</td>
        <td>
          <span class="badge ${statusClass}">
            <i class="fas fa-${statusIcon} me-1"></i> ${statusText}
          </span>
        </td>
      `;

        tbody.appendChild(tr);
    });
}

function updateEvolutionData() {
    if (!statsTemporelles || !statsTemporelles.annees) return;

    // Déterminer le type de période sélectionné
    const periodeType = document.querySelector('input[name="periode-type"]:checked').value;

    let donnees;
    switch (periodeType) {
        case 'annee':
            donnees = statsTemporelles.annees;
            break;
        case 'mois':
            donnees = statsTemporelles.mois;
            break;
        case 'semaine':
            donnees = statsTemporelles.semaines;
            break;
        default:
            donnees = statsTemporelles.annees;
    }

    // Créer le graphique
    createEvolutionChart(donnees, periodeType);

    // Mettre à jour le tableau
    updateEvolutionTable(donnees);
}

function updateEvolutionTable(donnees) {
    const tbody = document.getElementById('table-evolution').querySelector('tbody');
    tbody.innerHTML = '';

    // Calculer les tendances
    let tendances = [];

    if (donnees.length > 1) {
        for (let i = 1; i < donnees.length; i++) {
            const diff = donnees[i].rendement - donnees[i - 1].rendement;
            tendances.push({
                periode: donnees[i].periode,
                difference: diff,
                pourcentage: donnees[i - 1].rendement !== 0 ? (diff / donnees[i - 1].rendement * 100) : 0
            });
        }
        // Ajouter une entrée nulle pour la première période
        tendances.unshift({
            periode: donnees[0].periode,
            difference: 0,
            pourcentage: 0
        });
    } else {
        // S'il n'y a qu'une seule période, pas de tendance
        tendances = donnees.map(d => ({
            periode: d.periode,
            difference: 0,
            pourcentage: 0
        }));
    }

    donnees.forEach((stat, index) => {
        const tendance = tendances[index];
        let tendanceClass, tendanceIcon, tendanceText;

        if (tendance.difference > 0.01) {
            tendanceClass = 'badge-success';
            tendanceIcon = 'arrow-up';
            tendanceText = `+${tendance.pourcentage.toFixed(2)}%`;
        } else if (tendance.difference < -0.01) {
            tendanceClass = 'badge-danger';
            tendanceIcon = 'arrow-down';
            tendanceText = `${tendance.pourcentage.toFixed(2)}%`;
        } else {
            tendanceClass = 'badge-warning';
            tendanceIcon = 'equals';
            tendanceText = 'Stable';
        }

        const tr = document.createElement('tr');
        tr.innerHTML = `
            <td>${stat.periode}</td>
            <td>${stat.rendement.toFixed(4)}</td>
            <td>${stat.nbEntrees}</td>
            <td>
              <span class="badge ${tendanceClass}">
                <i class="fas fa-${tendanceIcon} me-1"></i> ${tendanceText}
              </span>
            </td>
          `;

        tbody.appendChild(tr);
    });
}


function updateOperateursSection() {
    // Générer les boutons de filtre pour les postes
    generatePosteFilterButtons();

    // Récupérer la liste des opérateurs qui ont des aléas
    google.script.run
        .withSuccessHandler(function (response) {
            if (response && response.success) {
                // Stocker la liste dans une variable temporaire
                const operateursAvecAleas = response.operateurs || [];

                // Mise à jour du graphique PARETO des rendements et du tableau des opérateurs
                // en passant la liste des opérateurs avec aléas
                createTopOperateursChart(false, false, 'all', operateursAvecAleas);
            } else {
                // Si erreur, afficher quand même le graphique et le tableau sans filtrer les boutons d'aléas
                createTopOperateursChart(false, false, 'all', []);
            }
        })
        .withFailureHandler(function (error) {
            console.error("Erreur lors de la récupération des opérateurs avec aléas:", error);
            // En cas d'erreur, afficher quand même le graphique et le tableau
            createTopOperateursChart(false, false, 'all', []);
        })
        .obtenirOperateursAvecAleas(activeFilters);
}


function updateOperateurDetailUI() {
    if (!detailOperateur || !detailOperateur.operateur) return;

    // Trouver les stats globales de l'opérateur
    const operateurGlobalStats = statsOperateurs.find(stat => stat.operateur === detailOperateur.operateur);

    // Afficher le SA à côté du nom de l'opérateur s'il est disponible
    const saDisplay = detailOperateur.sa ? ` (SA: ${detailOperateur.sa})` : '';
    document.getElementById('operateur-name').textContent = detailOperateur.operateur + saDisplay;

    if (operateurGlobalStats) {
        // Utiliser taiTotal et presenceTotal au lieu des moyennes
        const taiTotal = 'taiTotal' in operateurGlobalStats ? operateurGlobalStats.taiTotal : (operateurGlobalStats.taiMoyen * operateurGlobalStats.nbEntrees);
        const presenceTotal = 'presenceTotal' in operateurGlobalStats ? operateurGlobalStats.presenceTotal : (operateurGlobalStats.presenceMoyen * operateurGlobalStats.nbEntrees);

        // Mettre à jour les indicateurs
        document.getElementById('operateur-rendement').textContent = operateurGlobalStats.rendementMoyen.toFixed(4);
        document.getElementById('operateur-tai').textContent = taiTotal.toFixed(2);
        document.getElementById('operateur-presence').textContent = presenceTotal.toFixed(2);

        // Mettre à jour les labels pour indiquer qu'il s'agit maintenant de totaux
        document.querySelector('#operateur-tai').nextElementSibling.textContent = "TAI total";
        document.querySelector('#operateur-presence').nextElementSibling.textContent = "Présence totale (h)";
    } else {
        // Si nous n'avons pas les stats globales, utiliser directement les données de detailOperateur
        document.getElementById('operateur-rendement').textContent = detailOperateur.rendement?.toFixed(4) || "0.0000";
        document.getElementById('operateur-tai').textContent = detailOperateur.taiTotal?.toFixed(2) || "0.00";
        document.getElementById('operateur-presence').textContent = detailOperateur.presenceTotal?.toFixed(2) || "0.00";
    }

    // Créer les graphiques (seulement s'il y a des données)
    if (detailOperateur.rendements && detailOperateur.rendements.length > 0) {
        createOperateurEvolutionChart();
    }

    if (detailOperateur.statsPostes && detailOperateur.statsPostes.length > 0) {
        createOperateurPostesChart();
    }

    if (detailOperateur.statsEquipes && detailOperateur.statsEquipes.length > 0) {
        createOperateurEquipesChart();
    }

    // Mettre à jour le tableau des périodes (seulement s'il y a des données)
    if (detailOperateur.statsPeriodes && detailOperateur.statsPeriodes.length > 0) {
        updateOperateurPeriodesTable();
    }

    // Vérifier également que les fonctions de création de graphiques existent
    if (typeof createOperateurEvolutionChart !== 'function') {
        console.error("La fonction createOperateurEvolutionChart n'existe pas");
    }

    if (typeof createOperateurPostesChart !== 'function') {
        console.error("La fonction createOperateurPostesChart n'existe pas");
    }

    if (typeof createOperateurEquipesChart !== 'function') {
        console.error("La fonction createOperateurEquipesChart n'existe pas");
    }

    // Vérifier que les éléments HTML existent
    if (!document.getElementById('chart-operateur-evolution')) {
        console.error("L'élément chart-operateur-evolution n'existe pas");
    }

    if (!document.getElementById('chart-operateur-postes')) {
        console.error("L'élément chart-operateur-postes n'existe pas");
    }

    if (!document.getElementById('chart-operateur-equipes')) {
        console.error("L'élément chart-operateur-equipes n'existe pas");
    }
}

// Tableau des rendements individuels

function updateOperateurPeriodesTable() {
    if (!detailOperateur || !detailOperateur.statsPeriodes || detailOperateur.statsPeriodes.length === 0) {
        console.warn("Pas de données de périodes disponibles pour mettre à jour le tableau des périodes");
        return;
    }

    const tbody = document.getElementById('table-operateur-periodes').querySelector('tbody');
    if (!tbody) {
        console.error("Corps du tableau des périodes introuvable");
        return;
    }

    tbody.innerHTML = '';

    // Trouver la moyenne globale pour comparaison
    const moyenneGlobale = detailOperateur.rendement || 0;

    // Modification de l'en-tête pour remplacer "Entrées" par "Durée aléas (h)"
    const thead = document.getElementById('table-operateur-periodes').querySelector('thead tr');
    if (thead) {
        const headers = thead.querySelectorAll('th');
        if (headers.length >= 3 && headers[2].textContent === "Entrées") {
            headers[2].textContent = "Durée aléas (h)";
        }
    }

    // Fonction pour récupérer la durée des aléas d'un opérateur pour une période spécifique
    function getDureeAleasForOperateurPeriode(operateur, periode) {
        // Vérifier si nous avons des données d'aléas par période pour cet opérateur
        if (window.operateurDureesAleasPeriodes &&
            window.operateurDureesAleasPeriodes[operateur] &&
            window.operateurDureesAleasPeriodes[operateur][periode] !== undefined) {

            return window.operateurDureesAleasPeriodes[operateur][periode].toFixed(2);
        }

        // Vérifier si les données existent dans l'objet detailOperateur
        if (detailOperateur &&
            detailOperateur.operateur === operateur &&
            detailOperateur.dureesAleasPeriodes &&
            detailOperateur.dureesAleasPeriodes[periode] !== undefined) {

            return detailOperateur.dureesAleasPeriodes[periode].toFixed(2);
        }

        // Fallback : retourner une valeur par défaut
        return "0.00";
    }

    detailOperateur.statsPeriodes.forEach(stat => {
        // Définir le statut basé sur la comparaison avec la moyenne globale
        let statusClass, statusIcon, statusText;

        if (stat.rendement > moyenneGlobale * 1.05) {
            statusClass = 'badge-success';
            statusIcon = 'arrow-up';
            statusText = 'Au-dessus';
        } else if (stat.rendement < moyenneGlobale * 0.95) {
            statusClass = 'badge-danger';
            statusIcon = 'arrow-down';
            statusText = 'En-dessous';
        } else {
            statusClass = 'badge-warning';
            statusIcon = 'equals';
            statusText = 'Stable';
        }

        // Récupérer la durée des aléas pour cet opérateur et cette période
        const dureeAleas = getDureeAleasForOperateurPeriode(detailOperateur.operateur, stat.periode);

        const tr = document.createElement('tr');
        tr.innerHTML = `
        <td>${stat.periode}</td>
        <td>${stat.rendement.toFixed(4)}</td>
        <td>${dureeAleas}</td>
        <td>
          <span class="badge ${statusClass}">
            <i class="fas fa-${statusIcon} me-1"></i> ${statusText}
          </span>
        </td>
      `;

        tbody.appendChild(tr);
    });
}


/**
 * Graphiques
 */
function createTopPostesChart() {
    const ctx = document.getElementById('chart-top-postes').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.topPostesChart) {
        window.topPostesChart.destroy();
    }

    // Limiter aux 6 premiers postes
    const topPostes = [...statsPostes].slice(0, 6);

    const labels = topPostes.map(stat => stat.poste);
    const data = topPostes.map(stat => stat.rendementMoyen);
    const backgroundColor = CONFIG.colors.colors.slice(0, labels.length);

    // Créer le graphique
    window.topPostesChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Rendement moyen',
                data: data,
                backgroundColor: backgroundColor,
                borderWidth: 0,
                borderRadius: 6,
                maxBarThickness: 50
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y',
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        afterLabel: function (context) {
                            const stat = topPostes[context.dataIndex];
                            // Utiliser taiTotal et presenceTotal au lieu des moyennes
                            const taiTotal = 'taiTotal' in stat ? stat.taiTotal : (stat.taiMoyen * stat.nbEntrees);
                            const presenceTotal = 'presenceTotal' in stat ? stat.presenceTotal : (stat.presenceMoyen * stat.nbEntrees);

                            return [
                                `TAI total: ${taiTotal.toFixed(2)}`,
                                `Présence totale: ${presenceTotal.toFixed(2)} h`,
                                `Nombre d'entrées: ${stat.nbEntrees}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    grid: {
                        display: false
                    },
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                y: {
                    grid: {
                        display: false
                    }
                }
            }
        }
    });
}


/**
 * Créer les graphiques des opérateurs avec le plus d'aléas
 */
function createAleasOperateursCharts() {
    console.log("Création des graphiques des opérateurs avec le plus d'aléas");

    // Regrouper par opérateur
    const operateurData = {};

    aleasAnalysisData.forEach(alea => {
        const operateur = alea.operateur || 'Non spécifié';

        // Initialiser l'entrée pour cet opérateur si nécessaire
        if (!operateurData[operateur]) {
            operateurData[operateur] = {
                count: 0,
                duree: 0,
                types: {}
            };
        }

        // Incrémenter le compteur et la durée
        operateurData[operateur].count++;

        if (alea.duree && !isNaN(parseFloat(alea.duree))) {
            operateurData[operateur].duree += parseFloat(alea.duree);
        }

        // Compter par type d'aléa
        const type = alea.typeAlea || 'Non spécifié';
        if (!operateurData[operateur].types[type]) {
            operateurData[operateur].types[type] = 0;
        }
        operateurData[operateur].types[type]++;
    });

    // Convertir en tableaux pour le tri
    const operateurs = Object.keys(operateurData);
    const counts = operateurs.map(operateur => operateurData[operateur].count);
    const durees = operateurs.map(operateur => operateurData[operateur].duree);

    // Trier par nombre d'aléas décroissant et prendre les 10 premiers
    const sortedIndices = counts.map((count, index) => index)
        .sort((a, b) => counts[b] - counts[a]);

    const topN = Math.min(10, operateurs.length);
    const topIndices = sortedIndices.slice(0, topN);

    const topOperateurs = topIndices.map(index => operateurs[index]);
    const topCounts = topIndices.map(index => counts[index]);
    const topDurees = topIndices.map(index => durees[index]);

    // Créer le graphique du nombre d'aléas par opérateur
    createAleasOperateursCountChart(topOperateurs, topCounts);

    // Créer le graphique de la durée des aléas par opérateur
    createAleasOperateursDureeChart(topOperateurs, topDurees);
}

/**
 * Créer le graphique du nombre d'aléas par opérateur
 */
function createAleasOperateursCountChart(operateurs, counts) {
    // Obtenir le contexte du canvas
    const ctx = document.getElementById('chart-aleas-operateurs-count').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (aleasOperateursCountChart) {
        aleasOperateursCountChart.destroy();
    }

    // Définir les couleurs
    const backgroundColor = 'rgba(54, 162, 235, 0.7)';
    const borderColor = 'rgba(54, 162, 235, 1)';

    // Créer le graphique
    aleasOperateursCountChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: operateurs,
            datasets: [
                {
                    label: 'Nombre d\'aléas',
                    data: counts,
                    backgroundColor: backgroundColor,
                    borderColor: borderColor,
                    borderWidth: 1,
                    borderRadius: 5
                }
            ]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                title: {
                    display: true,
                    text: 'Top opérateurs par nombre d\'aléas',
                    font: {
                        size: 14,
                        weight: 'bold'
                    }
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Nombre d\'aléas'
                    }
                },
                y: {
                    grid: {
                        display: false
                    }
                }
            }
        }
    });
}

/**
 * Créer le graphique de la durée des aléas par opérateur
 */
function createAleasOperateursDureeChart(operateurs, durees) {
    // Obtenir le contexte du canvas
    const ctx = document.getElementById('chart-aleas-operateurs-duree').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (aleasOperateursDureeChart) {
        aleasOperateursDureeChart.destroy();
    }

    // Définir les couleurs
    const backgroundColor = 'rgba(255, 99, 132, 0.7)';
    const borderColor = 'rgba(255, 99, 132, 1)';

    // Créer le graphique
    aleasOperateursDureeChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: operateurs,
            datasets: [
                {
                    label: 'Durée totale des aléas (h)',
                    data: durees,
                    backgroundColor: backgroundColor,
                    borderColor: borderColor,
                    borderWidth: 1,
                    borderRadius: 5
                }
            ]
        },
        options: {
            indexAxis: 'y',
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                title: {
                    display: true,
                    text: 'Top opérateurs par durée d\'aléas',
                    font: {
                        size: 14,
                        weight: 'bold'
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            return `Durée: ${context.raw.toFixed(2)} h`;
                        }
                    }
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Durée (heures)'
                    }
                },
                y: {
                    grid: {
                        display: false
                    }
                }
            }
        }
    });
}
function createEquipesOverviewChart() {
    const ctx = document.getElementById('chart-equipes-overview').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.equipesOverviewChart) {
        window.equipesOverviewChart.destroy();
    }

    const labels = statsEquipes.map(stat => stat.equipe);
    const rendements = statsEquipes.map(stat => stat.rendementMoyen);
    const entrees = statsEquipes.map(stat => stat.nbEntrees);

    const maxEntrees = Math.max(...entrees);
    const normalizedEntrees = entrees.map(val => (val / maxEntrees) * 100); // Normalisé sur 100 pour la taille des bulles

    // Créer le graphique
    window.equipesOverviewChart = new Chart(ctx, {
        type: 'bubble',
        data: {
            datasets: statsEquipes.map((stat, index) => ({
                label: stat.equipe,
                data: [{
                    x: stat.rendementMoyen,
                    y: 'taiTotal' in stat ? stat.taiTotal : (stat.taiMoyen * stat.nbEntrees), // Utiliser TAI total
                    r: Math.max(5, (stat.nbEntrees / maxEntrees) * 20) // Taille min 5, max 20
                }],
                backgroundColor: CONFIG.colors.colors[index % CONFIG.colors.colors.length]
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const stat = statsEquipes[context.datasetIndex];
                            // Utiliser taiTotal et presenceTotal au lieu des moyennes
                            const taiTotal = 'taiTotal' in stat ? stat.taiTotal : (stat.taiMoyen * stat.nbEntrees);
                            const presenceTotal = 'presenceTotal' in stat ? stat.presenceTotal : (stat.presenceMoyen * stat.nbEntrees);

                            return [
                                `Équipe: ${stat.equipe}`,
                                `Rendement: ${stat.rendementMoyen.toFixed(4)}`,
                                `TAI total: ${taiTotal.toFixed(2)}`,
                                `Présence totale: ${presenceTotal.toFixed(2)} h`,
                                `Entrées: ${stat.nbEntrees}`
                            ];
                        }
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Rendement'
                    },
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: 'TAI Total'
                    }
                }
            }
        }
    });
}

function createPostesPerformanceChart() {
    const ctx = document.getElementById('chart-postes-performance').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.postesPerformanceChart) {
        window.postesPerformanceChart.destroy();
    }

    // Limiter aux 8 premiers postes
    const topPostes = [...statsPostes].slice(0, 8);

    const labels = topPostes.map(stat => stat.poste);
    const data = topPostes.map(stat => stat.rendementMoyen);
    const backgroundColor = CONFIG.colors.colors.slice(0, labels.length);

    // Récupérer les durées d'aléas pour les tooltips
    let dureesAleasParPoste = {};
    if (dureesAleasPostes && dureesAleasPostes.length > 0) {
        dureesAleasPostes.forEach(posteAlea => {
            dureesAleasParPoste[posteAlea.poste] = posteAlea.duree;
        });
    }

    // Créer des objectifs pour chaque poste
    const objectifsData = topPostes.map(stat => {
        // Récupérer l'objectif spécifique du poste ou utiliser l'objectif global par défaut
        return CONFIG.objectifs[stat.poste] || CONFIG.objectifs.global || 0.84;
    });

    // Colorer les barres en fonction de l'objectif
    const backgroundColorWithObjectif = topPostes.map((stat, index) => {
        const objectif = objectifsData[index];
        if (stat.rendementMoyen >= objectif) {
            return 'rgba(76, 201, 240, 0.7)'; // Bleu pour au-dessus de l'objectif
        } else {
            return 'rgba(247, 37, 133, 0.7)'; // Rouge pour en-dessous de l'objectif
        }
    });

    // Créer le graphique
    window.postesPerformanceChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Rendement moyen',
                    data: data,
                    backgroundColor: backgroundColorWithObjectif,
                    borderWidth: 0,
                    borderRadius: 6,
                    maxBarThickness: 60
                },
                {
                    label: 'Objectif',
                    data: objectifsData,
                    type: 'line',
                    borderColor: '#ffbe0b',
                    borderWidth: 2,
                    pointStyle: 'triangle',
                    pointRadius: 6,
                    pointBackgroundColor: '#ffbe0b',
                    pointBorderColor: '#fff',
                    fill: false,
                    tension: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true
                },
                tooltip: {
                    callbacks: {
                        afterLabel: function (context) {
                            const stat = topPostes[context.dataIndex];

                            if (context.datasetIndex === 0) {
                                const objectif = objectifsData[context.dataIndex];
                                const diff = stat.rendementMoyen - objectif;
                                const diffPct = (diff / objectif) * 100;

                                // Récupérer la durée des aléas pour ce poste
                                let dureeAleasInfo = "";
                                if (dureesAleasParPoste[stat.poste] !== undefined) {
                                    dureeAleasInfo = `Durée aléas: ${dureesAleasParPoste[stat.poste].toFixed(2)} h`;
                                }

                                return [
                                    `Objectif: ${objectif.toFixed(2)}`,
                                    `Écart: ${diff.toFixed(3)} (${diffPct.toFixed(1)}%)`,
                                    `TAI total: ${stat.taiTotal.toFixed(2)}`,
                                    `Présence totale: ${stat.presenceTotal.toFixed(2)} h`,
                                    dureeAleasInfo || "Aucun aléa déclaré",
                                    `Nombre d'entrées: ${stat.nbEntrees}`
                                ];
                            }
                            return [];
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    }
                }
            }
        }
    });
}

// Calculer et afficher les sommes de TAI par poste
function calculateAndDisplayTAISums() {
    if (!allData || !allData.donnees) return;

    // Calculer les sommes de TAI par poste
    const taiParPoste = {};
    let taiTotalGlobal = 0;

    allData.donnees.forEach(item => {
        if (item.poste && !isNaN(item.tai)) {
            // Si ce poste n'est pas encore dans notre objet, l'initialiser
            if (!taiParPoste[item.poste]) {
                taiParPoste[item.poste] = 0;
            }

            // Ajouter le TAI au poste
            taiParPoste[item.poste] += item.tai;

            // Ajouter au total global
            taiTotalGlobal += item.tai;
        }
    });

    // Mettre à jour l'indicateur de TAI total global
    document.getElementById('tai-total-global').textContent = taiTotalGlobal.toFixed(2);

    // Convertir en tableau pour tri
    const taiPostesArray = Object.entries(taiParPoste).map(([poste, taiTotal]) => ({
        poste,
        taiTotal,
        pourcentage: (taiTotal / taiTotalGlobal) * 100
    }));

    // Trier par TAI total décroissant
    taiPostesArray.sort((a, b) => b.taiTotal - a.taiTotal);

    // Mettre à jour le tableau
    const tbody = document.getElementById('table-tai-postes').querySelector('tbody');
    tbody.innerHTML = '';

    taiPostesArray.forEach(item => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
        <td><strong>${item.poste}</strong></td>
        <td>${item.taiTotal.toFixed(2)}</td>
        <td>${item.pourcentage.toFixed(2)}%</td>
      `;
        tbody.appendChild(tr);
    });
}

// Modification du tableau "Classement des opérateurs"
function updateOperateursTable(operateursFiltered, selectedPoste, operateursAvecAleas = []) {
    // Si aucun opérateur filtré n'est fourni, utiliser tous les opérateurs
    const operateurs = operateursFiltered || statsOperateurs;

    // Mise à jour du tableau
    const tbody = document.getElementById('table-operateurs').querySelector('tbody');
    tbody.innerHTML = '';

    // Mise à jour de l'en-tête pour refléter TAI total, Présence totale et Durée aléas
    const thead = document.getElementById('table-operateurs').querySelector('thead tr');
    const headers = thead.querySelectorAll('th');
    if (headers.length >= 6) {
        if (headers[3].textContent === "TAI") {
            headers[3].textContent = "TAI Total";
        }
        if (headers[4].textContent === "Présence") {
            headers[4].textContent = "Présence Totale";
        }
        if (headers[5].textContent === "Entrées") {
            headers[5].textContent = "Durée aléas (h)";
        }
    }

    // Fonction pour obtenir la durée totale des aléas pour un opérateur
    function getDureeAleasForOperateur(operateur) {
        // Utiliser les données réelles
        return dureesAleasOperateurs[operateur] ? dureesAleasOperateurs[operateur].toFixed(2) : "0.00";
    }

    // Ajouter chaque opérateur au tableau
    operateurs.forEach((stat, index) => {
        // Déterminer s'il y a un badge pour le top 3
        let rankBadge = '';

        // Récupérer le rendement selon le poste sélectionné
        let rendementValue = stat.rendementMoyen;
        if (selectedPoste && selectedPoste !== 'all' && stat.rendementParPoste && stat.rendementParPoste[selectedPoste] !== undefined) {
            rendementValue = stat.rendementParPoste[selectedPoste];
        }

        // Utiliser taiTotal et presenceTotal au lieu des moyennes
        const taiTotal = 'taiTotal' in stat ? stat.taiTotal : (stat.taiMoyen * stat.nbEntrees);
        const presenceTotal = 'presenceTotal' in stat ? stat.presenceTotal : (stat.presenceMoyen * stat.nbEntrees);

        // Récupérer la durée des aléas pour cet opérateur
        const dureeAleas = getDureeAleasForOperateur(stat.operateur);

        // Générer les boutons d'actions
        let actionsHtml = `
        <div class="btn-group btn-group-sm">
          <button class="btn btn-primary btn-view-operateur" data-operateur="${stat.operateur}" title="Voir détails">
            <i class="fas fa-eye"></i>
          </button>
      `;

        // Vérifier si l'opérateur a des aléas (avec une conversion en chaîne pour une comparaison plus sûre)
        const operateurStr = String(stat.operateur).trim();
        const hasAleas = Array.isArray(operateursAvecAleas) && operateursAvecAleas.some(op => String(op).trim() === operateurStr);

        // Ajouter le bouton d'aléas uniquement si l'opérateur a des aléas
        if (hasAleas) {
            actionsHtml += `
          <button class="btn btn-info btn-view-aleas" data-operateur="${stat.operateur}" title="Voir aléas">
            <i class="fas fa-clipboard-list"></i>
          </button>
        `;
        }

        actionsHtml += `</div>`;

        // Utiliser le numéro SA s'il est disponible, sinon utiliser l'opérateur
        const saValue = stat.sa || "N/A";

        // Générer la ligne du tableau - Afficher le SA avec le nom en title pour le survol
        const tr = document.createElement('tr');
        tr.innerHTML = `
        <td>${index + 1}</td>
        <td>
          ${rankBadge}
          <strong title="${stat.operateur}">${saValue}</strong>
        </td>
        <td>${rendementValue.toFixed(4)}</td>
        <td>${taiTotal.toFixed(2)}</td>
        <td>${presenceTotal.toFixed(2)}</td>
        <td>${dureeAleas}</td>
        <td>${actionsHtml}</td>
      `;

        tbody.appendChild(tr);
    });

    // Ajouter les écouteurs d'événements pour les boutons
    document.querySelectorAll('.btn-view-operateur').forEach(btn => {
        btn.addEventListener('click', function () {
            const operateur = this.getAttribute('data-operateur');
            document.getElementById('operateur-select').value = operateur;
            loadOperateurDetail();
        });
    });

    // Ajouter les écouteurs d'événements pour les boutons d'aléas
    document.querySelectorAll('.btn-view-aleas').forEach(btn => {
        btn.addEventListener('click', function () {
            const operateur = this.getAttribute('data-operateur');
            showOperateurAleas(operateur);
        });
    });
}


function createEquipesPerformanceChart() {
    const ctx = document.getElementById('chart-equipes-performance').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.equipesPerformanceChart) {
        window.equipesPerformanceChart.destroy();
    }

    const labels = statsEquipes.map(stat => stat.equipe);
    const rendements = statsEquipes.map(stat => stat.rendementMoyen);
    const tais = statsEquipes.map(stat => stat.taiMoyen);

    // Créer le graphique
    window.equipesPerformanceChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Rendement',
                    data: rendements,
                    backgroundColor: CONFIG.colors.colors[0],
                    borderWidth: 0,
                    borderRadius: 6,
                    maxBarThickness: 25,
                    order: 1
                },
                {
                    label: 'TAI (ajusté)',
                    data: tais.map(tai => tai / 100), // Divisé par 100 pour l'échelle
                    type: 'line',
                    borderColor: CONFIG.colors.colors[1],
                    backgroundColor: 'transparent',
                    borderWidth: 3,
                    pointRadius: 5,
                    pointBackgroundColor: CONFIG.colors.colors[1],
                    pointBorderColor: 'white',
                    pointBorderWidth: 2,
                    tension: 0.3,
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    mode: 'index',
                    callbacks: {
                        label: function (context) {
                            if (context.dataset.label === 'TAI (ajusté)') {
                                return `TAI: ${(context.raw * 100).toFixed(2)}`;
                            }
                            return `${context.dataset.label}: ${context.formattedValue}`;
                        },
                        afterBody: function (context) {
                            // Vérifier si context est un tableau valide et non vide
                            if (!context || !context.length || context.length === 0) {
                                return [];
                            }

                            // Obtenir l'index de l'équipe en toute sécurité
                            const dataIndex = context[0].dataIndex;
                            if (dataIndex === undefined || dataIndex < 0 || dataIndex >= statsEquipes.length) {
                                return [];
                            }

                            const equipe = statsEquipes[dataIndex];

                            // Vérifier que equipe et ses propriétés existent
                            if (!equipe) {
                                return [];
                            }

                            // Utiliser des valeurs par défaut si les propriétés n'existent pas
                            const presenceMoyen = equipe.presenceMoyen !== undefined ? equipe.presenceMoyen.toFixed(2) : '0.00';
                            const nbEntrees = equipe.nbEntrees !== undefined ? equipe.nbEntrees : '0';

                            return [
                                `Présence moyenne: ${presenceMoyen} h`,
                                `Nombre d'entrées: ${nbEntrees}`
                            ];
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    }
                }
            }
        }
    });
}

function createEvolutionChart(donnees, periodeType) {
    const ctx = document.getElementById('chart-evolution').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.evolutionChart) {
        window.evolutionChart.destroy();
    }

    // Formatage des labels selon le type de période
    let titreLabel;
    switch (periodeType) {
        case 'annee':
            titreLabel = 'Évolution par année';
            break;
        case 'mois':
            titreLabel = 'Évolution par mois';
            break;
        case 'semaine':
            titreLabel = 'Évolution par semaine';
            break;
        default:
            titreLabel = 'Évolution temporelle';
    }

    const labels = donnees.map(d => d.periode);
    const rendements = donnees.map(d => d.rendement);

    // Créer un gradient pour l'arrière-plan
    const gradient = ctx.createLinearGradient(0, 0, 0, 300);
    gradient.addColorStop(0, 'rgba(67, 97, 238, 0.3)');
    gradient.addColorStop(1, 'rgba(67, 97, 238, 0)');

    // Créer le graphique
    window.evolutionChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Rendement',
                data: rendements,
                backgroundColor: gradient,
                borderColor: CONFIG.colors.primary,
                borderWidth: 3,
                pointRadius: 5,
                pointBackgroundColor: CONFIG.colors.primary,
                pointBorderColor: 'white',
                pointBorderWidth: 2,
                fill: true,
                tension: 0.3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: titreLabel,
                    font: {
                        size: 16,
                        weight: 'bold'
                    },
                    padding: {
                        top: 10,
                        bottom: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            return `Rendement: ${context.raw.toFixed(4)}`;
                        },
                        afterLabel: function (context) {
                            return `Entrées: ${donnees[context.dataIndex].nbEntrees}`;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: false,
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

function createTopOperateursChart(hasMasquageData, hasDemasquageData, selectedPoste, operateursAvecAleas = []) {
    const ctx = document.getElementById('chart-top-operateurs').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.topOperateursChart) {
        window.topOperateursChart.destroy();
    }

    // Utiliser tous les opérateurs, pas seulement les 8 premiers
    const allOperateurs = [...statsOperateurs];

    // Si un poste spécifique est sélectionné, filtrer les données
    let operateursFiltered = allOperateurs;
    let chartTitle = 'Pareto des rendements par opérateur';

    if (selectedPoste && selectedPoste !== 'all') {
        // Filtrer par poste spécifique
        operateursFiltered = allOperateurs.filter(stat => {
            return stat.rendementParPoste && stat.rendementParPoste[selectedPoste] !== undefined;
        });
        chartTitle = `Pareto des rendements par opérateur - Poste: ${selectedPoste}`;
    }

    // Trier les opérateurs par rendement décroissant
    operateursFiltered.sort((a, b) => {
        if (selectedPoste && selectedPoste !== 'all') {
            // Trier par rendement du poste spécifique
            const rendA = a.rendementParPoste[selectedPoste] || 0;
            const rendB = b.rendementParPoste[selectedPoste] || 0;
            return rendB - rendA;
        } else {
            // Trier par rendement global
            return b.rendementMoyen - a.rendementMoyen;
        }
    });

    // Utiliser la valeur SA au lieu du nom de l'opérateur pour les libellés
    const labels = operateursFiltered.map(stat => stat.sa || stat.operateur);
    const originalOperateurs = operateursFiltered.map(stat => stat.operateur); // Garder les noms originaux pour les tooltips

    // Sélectionner le rendement approprié (global ou par poste)
    const rendements = operateursFiltered.map(stat => {
        if (selectedPoste && selectedPoste !== 'all') {
            return stat.rendementParPoste[selectedPoste] || 0;
        }
        return stat.rendementMoyen;
    });

    // Calculer la moyenne des rendements
    const rendementMoyen = rendements.length > 0 ?
        rendements.reduce((sum, value) => sum + value, 0) / rendements.length : 0;

    // Définir l'objectif de rendement en fonction du poste sélectionné ou utiliser la valeur par défaut
    let objectifRendement = 0.84; // Valeur par défaut

    // Si un poste spécifique est sélectionné et qu'il y a un objectif dans CONFIG, l'utiliser
    if (selectedPoste && selectedPoste !== 'all' && CONFIG.objectifs && CONFIG.objectifs[selectedPoste]) {
        objectifRendement = CONFIG.objectifs[selectedPoste] || objectifRendement;
    } else if (CONFIG.objectifs && CONFIG.objectifs.global) {
        // Sinon utiliser l'objectif global s'il existe
        objectifRendement = CONFIG.objectifs.global;
    } else if (CONFIG.seuils && CONFIG.seuils.rendement && CONFIG.seuils.rendement.bon) {
        // Fallback au seuil de rendement bon
        objectifRendement = CONFIG.seuils.rendement.bon;
    }

    // Définir les couleurs des barres - rouge pour les valeurs sous l'objectif
    const barColors = rendements.map(val => val < objectifRendement ? '#f72585' : CONFIG.colors.primary);

    // Préparer les datasets
    const datasets = [
        {
            label: selectedPoste && selectedPoste !== 'all' ? `Rendement - ${selectedPoste}` : 'Rendement opérateur',
            data: rendements,
            backgroundColor: barColors,
            borderWidth: 0,
            borderRadius: 6,
            maxBarThickness: 20,
            order: 1
        },
        {
            label: 'Moyenne',
            data: Array(labels.length).fill(rendementMoyen),
            type: 'line',
            borderColor: '#4cc9f0',
            borderWidth: 2,
            borderDash: [5, 5],
            pointStyle: false,
            tension: 0,
            order: 0
        },
        {
            label: `Objectif (${objectifRendement.toFixed(2)})`,
            data: Array(labels.length).fill(objectifRendement),
            type: 'line',
            borderColor: '#ffbe0b',
            borderWidth: 2,
            pointStyle: false,
            tension: 0,
            order: 0
        }
    ];

    // Créer le graphique
    window.topOperateursChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: chartTitle,
                    font: {
                        size: 16,
                        weight: 'bold'
                    },
                    padding: {
                        top: 10,
                        bottom: 20
                    }
                },
                legend: {
                    display: true,
                    position: 'top'
                },
                tooltip: {
                    callbacks: {
                        title: function (context) {
                            // Afficher le nom complet de l'opérateur dans le titre du tooltip
                            if (context.length > 0) {
                                const dataIndex = context[0].dataIndex;
                                return originalOperateurs[dataIndex];
                            }
                            return '';
                        },
                        label: function (context) {
                            const datasetLabel = context.dataset.label || '';
                            if (datasetLabel.includes('Rendement')) {
                                const value = context.raw || 0;
                                return `Rendement: ${value.toFixed(4)}`;
                            } else if (datasetLabel === 'Moyenne') {
                                return `Moyenne: ${rendementMoyen.toFixed(4)}`;
                            } else if (datasetLabel.includes('Objectif')) {
                                return `Objectif: ${objectifRendement.toFixed(2)}`;
                            }
                            return datasetLabel;
                        },
                        afterBody: function (context) {
                            if (!context || !context[0] || !context[0].dataset.label.includes('Rendement')) {
                                return [];
                            }

                            const dataIndex = context[0].dataIndex;
                            if (dataIndex < 0 || dataIndex >= operateursFiltered.length) {
                                return [];
                            }

                            const operateur = operateursFiltered[dataIndex];
                            if (!operateur) {
                                return [];
                            }

                            const details = [];

                            if (operateur.taiMoyen !== undefined) {
                                details.push(`TAI: ${operateur.taiMoyen.toFixed(2)}`);
                            }

                            if (operateur.presenceMoyen !== undefined) {
                                details.push(`Présence: ${operateur.presenceMoyen.toFixed(2)} h`);
                            }

                            if (operateur.nbEntrees !== undefined) {
                                details.push(`Entrées: ${operateur.nbEntrees}`);
                            }

                            return details;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Rendement'
                    },
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    },
                    title: {
                        display: true,
                        text: 'Opérateurs (SA)'
                    },
                    ticks: {
                        display: false // Ne pas afficher les numéros SA sur l'axe
                    }
                }
            }
        }
    });

    // Après avoir créé le graphique, mettre à jour le tableau des opérateurs avec le même filtrage
    updateOperateursTable(operateursFiltered, selectedPoste, operateursAvecAleas);
}

function generatePosteFilterButtons() {
    // Utiliser la variable globale allData qui contient les données
    const postesTypes = allData.postes || [];
    const buttonContainer = document.getElementById('poste-filter-buttons');

    // S'assurer que le conteneur existe et qu'il y a des postes
    if (!buttonContainer || !postesTypes || postesTypes.length === 0) {
        console.log("Impossible de générer les boutons de filtre: conteneur ou types de postes non disponibles");
        return;
    }

    // Garder uniquement le bouton "Tous les postes"
    buttonContainer.innerHTML = `
      <input type="radio" class="btn-check" name="poste-filter" id="poste-filter-all" value="all" checked>
      <label class="btn btn-outline-primary" for="poste-filter-all">
        Tous les postes
      </label>
    `;

    // Ajouter un bouton pour chaque type de poste
    postesTypes.forEach((poste, index) => {
        const buttonId = `poste-filter-${index}`;

        const radioInput = document.createElement('input');
        radioInput.type = 'radio';
        radioInput.className = 'btn-check';
        radioInput.name = 'poste-filter';
        radioInput.id = buttonId;
        radioInput.value = poste;

        const label = document.createElement('label');
        label.className = 'btn btn-outline-primary';
        label.htmlFor = buttonId;
        label.textContent = poste;

        buttonContainer.appendChild(radioInput);
        buttonContainer.appendChild(label);
    });

    // Ajouter l'écouteur d'événements pour les boutons radio
    document.querySelectorAll('input[name="poste-filter"]').forEach(radio => {
        radio.addEventListener('change', function () {
            // Mettre à jour le graphique et la table sans perdre l'information des aléas
            updateOperateursChart(); // Cette fonction utilisera maintenant le cache
        });
    });
}

function updateOperateursChart() {
    const selectedPoste = document.querySelector('input[name="poste-filter"]:checked').value;

    // Conserver la liste des opérateurs avec aléas entre les mises à jour de vue
    // Vérifier si nous avons déjà une liste stockée
    if (!window.cachedOperateursAvecAleas) {
        window.cachedOperateursAvecAleas = [];
    }

    // Récupérer la liste des opérateurs qui ont des aléas, seulement si nous n'avons pas déjà les données
    if (window.cachedOperateursAvecAleas.length === 0) {

        google.script.run
            .withSuccessHandler(function (response) {
                if (response && response.success) {
                    // Stocker la liste dans une variable globale pour les futures mises à jour
                    window.cachedOperateursAvecAleas = response.operateurs || [];


                    // Mettre à jour le graphique et le tableau avec les données mises en cache
                    createTopOperateursChart(
                        statsOperateurs.some(op => 'masquageMoyen' in op),
                        statsOperateurs.some(op => 'demasquageMoyen' in op),
                        selectedPoste,
                        window.cachedOperateursAvecAleas
                    );
                } else {
                    // Si erreur, mettre quand même à jour le graphique et le tableau
                    createTopOperateursChart(
                        statsOperateurs.some(op => 'masquageMoyen' in op),
                        statsOperateurs.some(op => 'demasquageMoyen' in op),
                        selectedPoste,
                        []
                    );
                }
            })
            .withFailureHandler(function (error) {
                console.error("Erreur lors de la récupération des opérateurs avec aléas:", error);
                // En cas d'erreur, mettre quand même à jour le graphique et le tableau
                createTopOperateursChart(
                    statsOperateurs.some(op => 'masquageMoyen' in op),
                    statsOperateurs.some(op => 'demasquageMoyen' in op),
                    selectedPoste,
                    []
                );
            })
            .obtenirOperateursAvecAleas(activeFilters);
    } else {
        // Utiliser les données déjà mises en cache
        console.log("Utilisation des opérateurs avec aléas mis en cache:", window.cachedOperateursAvecAleas);

        // Vérifier si les opérateurs ont des données MASQUAGE/DEMASQUAGE
        const hasMasquageData = statsOperateurs.some(op => 'masquageMoyen' in op);
        const hasDemasquageData = statsOperateurs.some(op => 'demasquageMoyen' in op);

        // Créer le graphique avec le poste sélectionné et la liste mise en cache
        createTopOperateursChart(hasMasquageData, hasDemasquageData, selectedPoste, window.cachedOperateursAvecAleas);
    }
}

function createOperateurEvolutionChart() {
    if (!detailOperateur.rendements || detailOperateur.rendements.length === 0) {
        console.warn("Pas de données de rendement pour le graphique d'évolution de l'opérateur");
        return;
    }

    const ctx = document.getElementById('chart-operateur-evolution');
    if (!ctx) {
        console.error("Canvas 'chart-operateur-evolution' introuvable");
        return;
    }

    // Détruire le graphique s'il existe déjà
    if (window.operateurEvolutionChart) {
        window.operateurEvolutionChart.destroy();
    }

    // S'assurer que les données sont au bon format
    const labels = detailOperateur.rendements.map(r => {
        // Vérifier si la date est au format ISO ou autre, et la formater correctement
        if (typeof r.date === 'string') {
            return r.date;
        } else if (r.date instanceof Date) {
            return r.date.toISOString().split('T')[0];
        }
        return "Date inconnue";
    });

    const data = detailOperateur.rendements.map(r => {
        // S'assurer que rendement est un nombre
        if (isNaN(r.rendement)) {
            console.warn("Valeur de rendement non numérique détectée:", r);
            return 0;
        }
        return r.rendement;
    });

    // Créer un gradient pour l'arrière-plan
    const gradient = ctx.getContext('2d').createLinearGradient(0, 0, 0, 300);
    gradient.addColorStop(0, 'rgba(67, 97, 238, 0.3)');
    gradient.addColorStop(1, 'rgba(67, 97, 238, 0)');

    // Créer le graphique
    window.operateurEvolutionChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{
                label: 'Rendement',
                data: data,
                backgroundColor: gradient,
                borderColor: CONFIG.colors.primary,
                borderWidth: 3,
                pointRadius: 5,
                pointBackgroundColor: CONFIG.colors.primary,
                pointBorderColor: 'white',
                pointBorderWidth: 2,
                fill: true,
                tension: 0.3
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: `Évolution du rendement - ${detailOperateur.operateur}`,
                    font: {
                        size: 16,
                        weight: 'bold'
                    },
                    padding: {
                        top: 10,
                        bottom: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            return `Rendement: ${context.raw.toFixed(4)}`;
                        },
                        afterLabel: function (context) {
                            const dataPoint = detailOperateur.rendements[context.dataIndex];
                            const details = [];

                            if (dataPoint) {
                                if (dataPoint.poste) details.push(`Poste: ${dataPoint.poste}`);
                                if (dataPoint.equipe) details.push(`Équipe: ${dataPoint.equipe}`);
                                if (dataPoint.tai) details.push(`TAI: ${dataPoint.tai.toFixed(2)}`);
                                if (dataPoint.presence) details.push(`Présence: ${dataPoint.presence.toFixed(2)} h`);
                            }

                            return details;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: false,
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            },
            interaction: {
                intersect: false,
                mode: 'index'
            }
        }
    });
}

function createOperateurPostesChart() {
    if (!detailOperateur.statsPostes || detailOperateur.statsPostes.length === 0) return;

    const ctx = document.getElementById('chart-operateur-postes').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.operateurPostesChart) {
        window.operateurPostesChart.destroy();
    }

    const labels = detailOperateur.statsPostes.map(stat => stat.poste);
    const data = detailOperateur.statsPostes.map(stat => stat.rendement);
    const backgroundColor = CONFIG.colors.colors.slice(0, labels.length);

    // Créer le graphique
    window.operateurPostesChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Rendement par poste',
                data: data,
                backgroundColor: backgroundColor,
                borderWidth: 0,
                borderRadius: 6,
                maxBarThickness: 50
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        afterLabel: function (context) {
                            const stat = detailOperateur.statsPostes[context.dataIndex];
                            return [`Nombre d'entrées: ${stat.nbEntrees}`];
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            }
        }
    });
}

/**
* Fonction pour afficher les aléas d'un opérateur
* @param {string} operateur - Nom de l'opérateur
*/
function showOperateurAleas(operateur) {
    // Initialiser la modale
    resetAleasModal();

    // Trouver l'opérateur dans les statistiques pour obtenir son SA
    const operateurStats = statsOperateurs.find(stat => stat.operateur === operateur);
    const saOperateur = operateurStats && operateurStats.sa ? operateurStats.sa : '';

    // Mettre à jour le titre - Afficher le SA à côté du nom si disponible
    const displayName = operateur + (saOperateur ? ` (SA: ${saOperateur})` : '');
    document.getElementById('aleas-operateur-name').textContent = displayName;

    // Afficher le spinner de chargement
    document.getElementById('aleas-loading').style.display = 'block';
    document.getElementById('aleas-content').style.display = 'none';
    document.getElementById('aleas-error').style.display = 'none';
    document.getElementById('aleas-empty').style.display = 'none';

    // Afficher la modale
    var aleasModal = new bootstrap.Modal(document.getElementById('aleas-modal'));
    aleasModal.show();

    // Récupérer les aléas avec les filtres actuels
    google.script.run
        .withSuccessHandler(function (response) {
            document.getElementById('aleas-loading').style.display = 'none';

            if (response.success) {
                if (response.aleas && response.aleas.length > 0) {
                    // Afficher les aléas dans le tableau
                    populateAleasTable(response.aleas);
                    document.getElementById('aleas-content').style.display = 'block';

                    // Mettre à jour le compteur d'aléas
                    document.getElementById('aleas-count').textContent = response.aleas.length + ' aléa' + (response.aleas.length > 1 ? 's' : '');

                    // Afficher les informations sur les filtres
                    if (activeFilters && (activeFilters.dateDebut || activeFilters.dateFin || activeFilters.poste || activeFilters.equipe)) {
                        let filtersInfo = "Filtré par: ";
                        let hasFilter = false;

                        if (activeFilters.dateDebut && activeFilters.dateFin) {
                            filtersInfo += "période du " + formatDate(activeFilters.dateDebut) + " au " + formatDate(activeFilters.dateFin);
                            hasFilter = true;
                        } else if (activeFilters.dateDebut) {
                            filtersInfo += "date après " + formatDate(activeFilters.dateDebut);
                            hasFilter = true;
                        } else if (activeFilters.dateFin) {
                            filtersInfo += "date avant " + formatDate(activeFilters.dateFin);
                            hasFilter = true;
                        }

                        if (activeFilters.poste) {
                            filtersInfo += (hasFilter ? ", " : "") + "poste '" + activeFilters.poste + "'";
                            hasFilter = true;
                        }

                        if (activeFilters.equipe) {
                            filtersInfo += (hasFilter ? ", " : "") + "équipe '" + activeFilters.equipe + "'";
                        }

                        document.getElementById('aleas-filters-info').textContent = filtersInfo;
                    } else {
                        document.getElementById('aleas-filters-info').textContent = "Aucun filtre appliqué";
                    }

                } else {
                    // Aucun aléa trouvé
                    document.getElementById('aleas-empty').style.display = 'block';
                }
            } else {
                // Erreur
                document.getElementById('aleas-error').textContent = response.message || "Une erreur est survenue lors du chargement des aléas.";
                document.getElementById('aleas-error').style.display = 'block';
            }
        })
        .withFailureHandler(function (error) {
            document.getElementById('aleas-loading').style.display = 'none';
            document.getElementById('aleas-error').textContent = "Erreur: " + error;
            document.getElementById('aleas-error').style.display = 'block';
        })
        .obtenirAleasOperateur(operateur, activeFilters);
}


/**
 * Initialisation de l'onglet d'analyse des aléas
 */
// Dans la section des variables globales au début du script, ajoutez :
let aleasAnalysisData = [];
let aleasTypeChart, aleasPosteChart, aleasEquipeChart, aleasEvolutionChart,
    aleasOperateursCountChart, aleasOperateursDureeChart;

// Puis remplacez les deux versions fragmentées de initAleasAnalysisTab() par cette version complète :
function initAleasAnalysisTab() {
    console.log("Initialisation de l'onglet d'analyse des aléas");

    // Ajouter des écouteurs d'événements
    document.getElementById('btn-refresh-aleas-analysis').addEventListener('click', loadAleasAnalysisData);
    document.querySelectorAll('input[name="aleas-periode-type"]').forEach(input => {
        input.addEventListener('change', updateAleasEvolutionChart);
    });

    // Chargement initial des données quand on clique sur l'onglet
    document.getElementById('tab-aleas').addEventListener('click', function () {
        console.log("Clic sur l'onglet Analyse Aléas");
        document.getElementById('operateur-selector').style.display = 'none';

        // Vérifier si les données ont déjà été chargées
        if (!aleasAnalysisData || aleasAnalysisData.length === 0) {
            loadAleasAnalysisData();
        }
    });
}


/**
 * Charger les données d'aléas pour l'analyse
 */
function loadAleasAnalysisData() {
    // Afficher le chargement
    console.log("Chargement des données d'analyse des aléas...");
    document.getElementById('aleas-analysis-loading').style.display = 'block';
    document.getElementById('aleas-analysis-content').style.display = 'none';
    document.getElementById('aleas-analysis-error').style.display = 'none';
    document.getElementById('aleas-analysis-empty').style.display = 'none';

    // Appeler la fonction côté serveur pour obtenir tous les aléas avec les filtres actuels
    google.script.run
        .withSuccessHandler(function (response) {
            document.getElementById('aleas-analysis-loading').style.display = 'none';

            if (response.success) {
                if (response.aleas && response.aleas.length > 0) {
                    // Stocker les données
                    aleasAnalysisData = response.aleas;

                    // Mettre à jour l'interface
                    updateAleasAnalysisUI();
                    document.getElementById('aleas-analysis-content').style.display = 'block';
                } else {
                    // Aucun aléa trouvé
                    document.getElementById('aleas-analysis-empty').style.display = 'block';
                }
            } else {
                // Erreur
                document.getElementById('aleas-analysis-error').textContent = response.message || "Une erreur est survenue lors du chargement des aléas.";
                document.getElementById('aleas-analysis-error').style.display = 'block';
            }
        })
        .withFailureHandler(function (error) {
            document.getElementById('aleas-analysis-loading').style.display = 'none';
            document.getElementById('aleas-analysis-error').textContent = "Erreur: " + error;
            document.getElementById('aleas-analysis-error').style.display = 'block';
        })
        .obtenirTousAleas(activeFilters);
}

/**
 * Mettre à jour l'interface d'analyse des aléas
 */
// Variables pour la pagination du tableau des aléas
let currentAleasPage = 1;
const aleasPerPage = 20;
let filteredAleasData = [];

/**
 * Mise à jour de l'interface d'analyse des aléas
 */
function updateAleasAnalysisUI() {
    // Mettre à jour les indicateurs
    console.log("Mise à jour de l'interface d'analyse des aléas");
    updateAleasIndicators();

    // Créer/Mettre à jour les graphiques
    createAleasTypeChart();
    createAleasPosteChart();
    createAleasEquipeChart();
    updateAleasEvolutionChart();
    createAleasOperateursCharts();

    // Mise à jour du tableau des aléas
    updateAleasAnalysisTable();
}

/**
 * Mettre à jour le tableau des aléas dans l'onglet d'analyse
 */
function updateAleasAnalysisTable() {
    // Réinitialiser la pagination
    currentAleasPage = 1;

    // Copier les données pour pouvoir les filtrer sans affecter l'original
    filteredAleasData = [...aleasAnalysisData];

    // Mettre à jour l'affichage du tableau
    populateAleasAnalysisTable();

    // Mettre à jour le compteur
    document.getElementById('aleas-analysis-table-count').textContent = filteredAleasData.length + ' aléa' + (filteredAleasData.length > 1 ? 's' : '');

    // Mettre à jour les informations sur les filtres
    updateAleasTableFiltersInfo();

    // Ajouter l'écouteur d'événement pour l'exportation
    document.getElementById('btn-export-aleas-analysis').onclick = function () {
        exportAleasToCSV(filteredAleasData, 'tous_aleas');
    };

    // Mettre à jour les boutons de pagination
    updatePaginationButtons();
}

/**
 * Mettre à jour les informations de filtres pour le tableau d'aléas
 */
function updateAleasTableFiltersInfo() {
    // Afficher les informations sur les filtres
    if (activeFilters && (activeFilters.dateDebut || activeFilters.dateFin || activeFilters.poste || activeFilters.equipe)) {
        let filtersInfo = "Filtré par: ";
        let hasFilter = false;

        if (activeFilters.dateDebut && activeFilters.dateFin) {
            filtersInfo += "période du " + formatDate(activeFilters.dateDebut) + " au " + formatDate(activeFilters.dateFin);
            hasFilter = true;
        } else if (activeFilters.dateDebut) {
            filtersInfo += "date après " + formatDate(activeFilters.dateDebut);
            hasFilter = true;
        } else if (activeFilters.dateFin) {
            filtersInfo += "date avant " + formatDate(activeFilters.dateFin);
            hasFilter = true;
        }

        if (activeFilters.poste) {
            filtersInfo += (hasFilter ? ", " : "") + "poste '" + activeFilters.poste + "'";
            hasFilter = true;
        }

        if (activeFilters.equipe) {
            filtersInfo += (hasFilter ? ", " : "") + "équipe '" + activeFilters.equipe + "'";
        }

        document.getElementById('aleas-analysis-table-filters-info').textContent = filtersInfo;
    } else {
        document.getElementById('aleas-analysis-table-filters-info').textContent = "Aucun filtre appliqué";
    }
}

/**
 * Remplir le tableau d'aléas avec la page actuelle de données
 */
function populateAleasAnalysisTable() {
    const tbody = document.getElementById('aleas-analysis-table-body');
    tbody.innerHTML = '';

    // Calculer les indices de début et de fin pour la pagination
    const start = (currentAleasPage - 1) * aleasPerPage;
    const end = Math.min(start + aleasPerPage, filteredAleasData.length);

    // Mettre à jour l'information de pagination
    document.getElementById('aleas-pagination-info').textContent = `Affichage de ${start + 1}-${end} sur ${filteredAleasData.length}`;

    // N'afficher que les aléas de la page actuelle
    const pageData = filteredAleasData.slice(start, end);

    // Ajouter chaque aléa au tableau
    pageData.forEach(function (alea) {
        const tr = document.createElement('tr');

        // Déterminer la classe pour le type d'aléa
        let typeBadgeClass = 'bg-secondary';
        switch (alea.typeAlea) {
            case 'Qualité':
                typeBadgeClass = 'bg-primary';
                break;
            case 'Prépa':
                typeBadgeClass = 'bg-info';
                break;
            case 'Maintenance':
                typeBadgeClass = 'bg-warning text-dark';
                break;
            case 'Formation':
                typeBadgeClass = 'bg-success';
                break;
            case 'Réunion':
                typeBadgeClass = 'bg-danger';
                break;
        }

        // Formater le commentaire (affecter une longueur maximale avec ellipsis)
        let commentaire = alea.commentaire || '';
        const commentaireComplet = commentaire;
        let commentaireAffiche = commentaire;

        if (commentaire.length > 50) {
            commentaireAffiche = commentaire.substring(0, 47) + '...';
        }

        tr.innerHTML = `
        <td>${alea.date}</td>
        <td>${alea.operateur || '-'}</td>
        <td>${alea.equipe || '-'}</td>
        <td>${alea.poste || '-'}</td>
        <td><span class="badge ${typeBadgeClass}">${alea.typeAlea || 'Non spécifié'}</span></td>
        <td>${alea.duree || '-'}</td>
        <td>${commentaireAffiche ? `<span title="${commentaireComplet}">${commentaireAffiche}</span>` : '-'}</td>
      `;

        tbody.appendChild(tr);
    });
}

/**
 * Mettre à jour les boutons de pagination
 */
function updatePaginationButtons() {
    const totalPages = Math.ceil(filteredAleasData.length / aleasPerPage);

    // Activer/désactiver les boutons de pagination
    document.getElementById('btn-prev-page').disabled = currentAleasPage <= 1;
    document.getElementById('btn-next-page').disabled = currentAleasPage >= totalPages;
}

/**
 * Filtrer le tableau d'aléas selon le terme de recherche
 */
function filterAleasAnalysisTable() {
    const searchTerm = document.getElementById('aleas-analysis-search').value.toLowerCase().trim();

    // Si aucun terme de recherche, utiliser les données complètes
    if (!searchTerm) {
        filteredAleasData = [...aleasAnalysisData];
    } else {
        // Filtrer les données
        filteredAleasData = aleasAnalysisData.filter(alea => {
            return (
                (alea.operateur && alea.operateur.toLowerCase().includes(searchTerm)) ||
                (alea.equipe && alea.equipe.toLowerCase().includes(searchTerm)) ||
                (alea.poste && alea.poste.toLowerCase().includes(searchTerm)) ||
                (alea.typeAlea && alea.typeAlea.toLowerCase().includes(searchTerm)) ||
                (alea.commentaire && alea.commentaire.toLowerCase().includes(searchTerm))
            );
        });
    }

    // Réinitialiser la pagination
    currentAleasPage = 1;

    // Mettre à jour l'affichage
    populateAleasAnalysisTable();

    // Mettre à jour le compteur
    document.getElementById('aleas-analysis-table-count').textContent = filteredAleasData.length + ' aléa' + (filteredAleasData.length > 1 ? 's' : '');

    // Mettre à jour les boutons de pagination
    updatePaginationButtons();
}

/**
 * Initialisation des événements pour l'onglet d'analyse des aléas
 */
function initAleasAnalysisTab() {
    console.log("Initialisation de l'onglet d'analyse des aléas");

    // Ajouter des écouteurs d'événements
    document.getElementById('btn-refresh-aleas-analysis').addEventListener('click', loadAleasAnalysisData);
    document.querySelectorAll('input[name="aleas-periode-type"]').forEach(input => {
        input.addEventListener('change', updateAleasEvolutionChart);
    });

    // Chargement initial des données quand on clique sur l'onglet
    document.getElementById('tab-aleas').addEventListener('click', function () {
        console.log("Clic sur l'onglet Analyse Aléas");
        document.getElementById('operateur-selector').style.display = 'none';

        // Vérifier si les données ont déjà été chargées
        if (!aleasAnalysisData || aleasAnalysisData.length === 0) {
            loadAleasAnalysisData();
        }
    });

    // Écouteurs pour la pagination et la recherche
    document.getElementById('btn-prev-page').addEventListener('click', function () {
        if (currentAleasPage > 1) {
            currentAleasPage--;
            populateAleasAnalysisTable();
            updatePaginationButtons();
        }
    });

    document.getElementById('btn-next-page').addEventListener('click', function () {
        const totalPages = Math.ceil(filteredAleasData.length / aleasPerPage);
        if (currentAleasPage < totalPages) {
            currentAleasPage++;
            populateAleasAnalysisTable();
            updatePaginationButtons();
        }
    });

    document.getElementById('aleas-analysis-search').addEventListener('input', filterAleasAnalysisTable);

    document.getElementById('btn-clear-aleas-search').addEventListener('click', function () {
        document.getElementById('aleas-analysis-search').value = '';
        filterAleasAnalysisTable();
    });
}

/**
 * Mettre à jour les indicateurs principaux des aléas
 */
function updateAleasIndicators() {
    // Nombre total d'aléas
    const totalAleas = aleasAnalysisData.length;
    document.getElementById('aleas-count-indicator').textContent = totalAleas;

    // Durée totale des aléas (en heures)
    let totalDuree = 0;
    let validDureeCount = 0;

    aleasAnalysisData.forEach(alea => {
        if (alea.duree && !isNaN(parseFloat(alea.duree))) {
            totalDuree += parseFloat(alea.duree);
            validDureeCount++;
        }
    });

    document.getElementById('aleas-duree-total').textContent = totalDuree.toFixed(2);

    // Durée moyenne des aléas
    const dureeMoyenne = validDureeCount > 0 ? totalDuree / validDureeCount : 0;
    document.getElementById('aleas-duree-moyenne').textContent = dureeMoyenne.toFixed(2);

    // Impact sur la production (estimation approximative)
    // Nous pouvons estimer cela en fonction du temps total de présence disponible
    // Pour simplifier, supposons 8 heures par jour × nombre d'opérateurs uniques
    const uniqueOperateurs = new Set(aleasAnalysisData.map(alea => alea.operateur)).size;

    // Si la période est d'environ 1 mois (20 jours ouvrables)
    const totalHeuresTravail = uniqueOperateurs * 8 * 20; // estimatif
    const impactPercent = totalHeuresTravail > 0 ? (totalDuree / totalHeuresTravail) * 100 : 0;

    document.getElementById('aleas-impact-percent').textContent = impactPercent.toFixed(2) + '%';
}

/**
 * Créer le graphique Pareto des types d'aléas
 */
/**
 * Créer le graphique Pareto des types d'aléas
 */
function createAleasTypeChart() {
    // Regrouper par type d'aléa
    const typeCount = {};
    const typeDuree = {};

    aleasAnalysisData.forEach(alea => {
        const type = alea.typeAlea || 'Non spécifié';

        // Compter les occurrences
        if (!typeCount[type]) {
            typeCount[type] = 0;
            typeDuree[type] = 0;
        }
        typeCount[type]++;

        // Additionner les durées si disponibles
        if (alea.duree && !isNaN(parseFloat(alea.duree))) {
            typeDuree[type] += parseFloat(alea.duree);
        }
    });

    // Convertir en tableaux pour le tri
    const types = Object.keys(typeCount);
    const counts = types.map(type => typeCount[type]);
    const durees = types.map(type => typeDuree[type]);

    // Trier par heures d'aléas décroissant (au lieu du nombre d'occurrences)
    const sortedIndices = durees.map((duree, index) => index)
        .sort((a, b) => durees[b] - durees[a]);

    const sortedTypes = sortedIndices.map(index => types[index]);
    const sortedCounts = sortedIndices.map(index => counts[index]);
    const sortedDurees = sortedIndices.map(index => durees[index]);

    // Calculer le pourcentage cumulé pour la courbe de Pareto (basé sur les heures)
    const totalDuree = sortedDurees.reduce((a, b) => a + b, 0);
    let cumulativePercent = 0;
    const cumulativeData = sortedDurees.map(duree => {
        cumulativePercent += (duree / totalDuree) * 100;
        return cumulativePercent;
    });

    // Définir les couleurs en fonction des types d'aléas
    const typeColors = {
        'Qualité': 'rgba(52, 152, 219, 0.7)',
        'Prépa': 'rgba(155, 89, 182, 0.7)',
        'Maintenance': 'rgba(241, 196, 15, 0.7)',
        'Formation': 'rgba(46, 204, 113, 0.7)',
        'Réunion': 'rgba(231, 76, 60, 0.7)',
        'Non spécifié': 'rgba(149, 165, 166, 0.7)'
    };

    const backgroundColor = sortedTypes.map(type => typeColors[type] || 'rgba(149, 165, 166, 0.7)');

    // Obtenir le contexte du canvas
    const ctx = document.getElementById('chart-aleas-types').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (aleasTypeChart) {
        aleasTypeChart.destroy();
    }

    // Créer le graphique
    aleasTypeChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: sortedTypes,
            datasets: [
                {
                    label: 'Heures d\'aléas',
                    data: sortedDurees,
                    backgroundColor: backgroundColor,
                    borderWidth: 1,
                    borderRadius: 5,
                    order: 2
                },
                {
                    label: 'Nombre d\'occurrences',
                    data: sortedCounts,
                    backgroundColor: 'rgba(255, 99, 132, 0.7)',
                    borderWidth: 1,
                    borderRadius: 5,
                    order: 1,
                    hidden: true
                },
                {
                    label: 'Pourcentage cumulé',
                    data: cumulativeData,
                    type: 'line',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: 'rgba(54, 162, 235, 1)',
                    yAxisID: 'percentage',
                    order: 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    mode: 'index',
                    callbacks: {
                        label: function (context) {
                            if (context.dataset.label === 'Pourcentage cumulé') {
                                return `${context.dataset.label}: ${context.raw.toFixed(1)}%`;
                            } else if (context.dataset.label === 'Heures d\'aléas') {
                                return `${context.dataset.label}: ${context.raw.toFixed(2)} h`;
                            } else if (context.dataset.label === 'Nombre d\'occurrences') {
                                return `${context.dataset.label}: ${context.raw}`;
                            }
                            return `${context.dataset.label}: ${context.raw}`;
                        }
                    }
                },
                legend: {
                    position: 'top',
                }
            },
            scales: {
                x: {
                    grid: {
                        display: false
                    }
                },
                y: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Heures d\'aléas'
                    }
                },
                percentage: {
                    position: 'right',
                    beginAtZero: true,
                    max: 100,
                    title: {
                        display: true,
                        text: 'Pourcentage cumulé'
                    },
                    grid: {
                        display: false
                    },
                    ticks: {
                        callback: function (value) {
                            return `${value}%`;
                        }
                    }
                }
            }
        }
    });
}

/**
 * Créer le graphique de répartition des aléas par poste
 */
function createAleasPosteChart() {
    // Regrouper par poste
    const posteCount = {};
    const posteDuree = {};

    aleasAnalysisData.forEach(alea => {
        const poste = alea.poste || 'Non spécifié';

        // Compter les occurrences
        if (!posteCount[poste]) {
            posteCount[poste] = 0;
            posteDuree[poste] = 0;
        }
        posteCount[poste]++;

        // Additionner les durées si disponibles
        if (alea.duree && !isNaN(parseFloat(alea.duree))) {
            posteDuree[poste] += parseFloat(alea.duree);
        }
    });

    // Convertir en tableaux pour le tri
    const postes = Object.keys(posteCount);
    const counts = postes.map(poste => posteCount[poste]);
    const durees = postes.map(poste => posteDuree[poste]);

    // Trier par nombre d'occurrences décroissant
    const sortedIndices = counts.map((count, index) => index)
        .sort((a, b) => counts[b] - counts[a]);

    // Limiter à 10 postes maximum pour la lisibilité
    const maxPostes = 10;
    const limitedIndices = sortedIndices.slice(0, maxPostes);

    const sortedPostes = limitedIndices.map(index => postes[index]);
    const sortedCounts = limitedIndices.map(index => counts[index]);
    const sortedDurees = limitedIndices.map(index => durees[index]);

    // Générer des couleurs
    const colors = [];
    for (let i = 0; i < sortedPostes.length; i++) {
        const hue = (i * 360 / sortedPostes.length) % 360;
        colors.push(`hsla(${hue}, 70%, 60%, 0.7)`);
    }

    // Obtenir le contexte du canvas
    const ctx = document.getElementById('chart-aleas-postes').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (aleasPosteChart) {
        aleasPosteChart.destroy();
    }

    // Créer le graphique
    aleasPosteChart = new Chart(ctx, {
        type: 'pie',
        data: {
            labels: sortedPostes,
            datasets: [
                {
                    label: 'Nombre d\'aléas',
                    data: sortedCounts,
                    backgroundColor: colors,
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const label = context.label || '';
                            const value = context.raw || 0;
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((value / total) * 100).toFixed(1);
                            const duree = sortedDurees[context.dataIndex].toFixed(2);
                            return [`${label}: ${value} (${percentage}%)`, `Durée: ${duree} h`];
                        }
                    }
                },
                legend: {
                    position: 'right',
                    labels: {
                        boxWidth: 12,
                        padding: 10
                    }
                },
                datalabels: {
                    formatter: (value, ctx) => {
                        const total = ctx.dataset.data.reduce((a, b) => a + b, 0);
                        const percentage = ((value / total) * 100).toFixed(1);
                        return percentage + '%';
                    },
                    color: '#fff',
                    font: {
                        weight: 'bold',
                        size: 10
                    }
                }
            }
        }
    });
}

/**
 * Créer le graphique de répartition des aléas par équipe
 */
function createAleasEquipeChart() {
    // Regrouper par équipe
    const equipeCount = {};
    const equipeDuree = {};

    aleasAnalysisData.forEach(alea => {
        const equipe = alea.equipe || 'Non spécifié';

        // Compter les occurrences
        if (!equipeCount[equipe]) {
            equipeCount[equipe] = 0;
            equipeDuree[equipe] = 0;
        }
        equipeCount[equipe]++;

        // Additionner les durées si disponibles
        if (alea.duree && !isNaN(parseFloat(alea.duree))) {
            equipeDuree[equipe] += parseFloat(alea.duree);
        }
    });

    // Convertir en tableaux pour le tri
    const equipes = Object.keys(equipeCount);
    const counts = equipes.map(equipe => equipeCount[equipe]);
    const durees = equipes.map(equipe => equipeDuree[equipe]);

    // Trier par nombre d'occurrences décroissant
    const sortedIndices = counts.map((count, index) => index)
        .sort((a, b) => counts[b] - counts[a]);

    const sortedEquipes = sortedIndices.map(index => equipes[index]);
    const sortedCounts = sortedIndices.map(index => counts[index]);
    const sortedDurees = sortedIndices.map(index => durees[index]);

    // Générer des couleurs
    const colors = [];
    for (let i = 0; i < sortedEquipes.length; i++) {
        const hue = (i * 360 / sortedEquipes.length + 120) % 360; // Décalage pour avoir des couleurs différentes du graphique postes
        colors.push(`hsla(${hue}, 70%, 60%, 0.7)`);
    }

    // Obtenir le contexte du canvas
    const ctx = document.getElementById('chart-aleas-equipes').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (aleasEquipeChart) {
        aleasEquipeChart.destroy();
    }

    // Créer le graphique
    aleasEquipeChart = new Chart(ctx, {
        type: 'doughnut',
        data: {
            labels: sortedEquipes,
            datasets: [
                {
                    label: 'Nombre d\'aléas',
                    data: sortedCounts,
                    backgroundColor: colors,
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function (context) {
                            const label = context.label || '';
                            const value = context.raw || 0;
                            const total = context.dataset.data.reduce((a, b) => a + b, 0);
                            const percentage = ((value / total) * 100).toFixed(1);
                            const duree = sortedDurees[context.dataIndex].toFixed(2);
                            return [`${label}: ${value} (${percentage}%)`, `Durée: ${duree} h`];
                        }
                    }
                },
                legend: {
                    position: 'right',
                    labels: {
                        boxWidth: 12,
                        padding: 10
                    }
                }
            }
        }
    });
}


/**
 * Mettre à jour le graphique d'évolution des aléas dans le temps
 */
function updateAleasEvolutionChart() {
    // Si les données n'ont pas été chargées, ne rien faire
    if (!aleasAnalysisData || aleasAnalysisData.length === 0) return;

    // Déterminer le type de période
    const periodeType = document.querySelector('input[name="aleas-periode-type"]:checked').value;

    // Regrouper par période (mois ou semaine)
    const periodeData = {};

    aleasAnalysisData.forEach(alea => {
        if (!alea.date) return;

        const dateParts = alea.date.split('/');
        if (dateParts.length !== 3) return;

        const year = dateParts[2];
        const month = dateParts[1];

        let periode;
        if (periodeType === 'mois') {
            periode = `${year}-${month}`;
        } else {
            // Pour calculer la semaine, on pourrait utiliser une méthode plus précise
            // mais pour simplifier, on va approximer par groupes de 7 jours
            const day = parseInt(dateParts[0]);
            const weekNum = Math.ceil(day / 7);
            periode = `${year}-${month}-S${weekNum}`;
        }

        // Initialiser la période si nécessaire
        if (!periodeData[periode]) {
            periodeData[periode] = {
                count: 0,
                duree: 0
            };
        }

        // Incrémenter le compteur et la durée
        periodeData[periode].count++;

        if (alea.duree && !isNaN(parseFloat(alea.duree))) {
            periodeData[periode].duree += parseFloat(alea.duree);
        }
    });

    // Convertir en tableaux pour le tri
    const periodes = Object.keys(periodeData);

    // Trier chronologiquement
    periodes.sort();

    const counts = periodes.map(periode => periodeData[periode].count);
    const durees = periodes.map(periode => periodeData[periode].duree);

    // Formater les étiquettes pour l'affichage
    let displayLabels = periodes;
    if (periodeType === 'mois') {
        const months = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sep', 'Oct', 'Nov', 'Déc'];
        displayLabels = periodes.map(periode => {
            const [year, month] = periode.split('-');
            return `${months[parseInt(month) - 1]} ${year}`;
        });
    } else {
        displayLabels = periodes.map(periode => {
            const parts = periode.split('-');
            if (parts.length === 3) {
                return `${parts[1]}-${parts[2]}`;
            }
            return periode;
        });
    }

    // Obtenir le contexte du canvas
    const ctx = document.getElementById('chart-aleas-evolution').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (aleasEvolutionChart) {
        aleasEvolutionChart.destroy();
    }

    // Si aucune donnée n'est disponible, ne pas créer le graphique
    if (periodes.length === 0) {
        console.log("Aucune donnée disponible pour le graphique d'évolution des aléas");
        return;
    }

    // Créer le graphique
    aleasEvolutionChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: displayLabels,
            datasets: [
                {
                    label: 'Nombre d\'aléas',
                    data: counts,
                    backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    borderWidth: 1,
                    borderRadius: 5,
                    order: 1,
                    yAxisID: 'count'
                },
                {
                    label: 'Durée (heures)',
                    data: durees,
                    backgroundColor: 'rgba(255, 99, 132, 0.7)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 2,
                    pointRadius: 4,
                    pointBackgroundColor: 'rgba(255, 99, 132, 1)',
                    type: 'line',
                    order: 0,
                    yAxisID: 'duree'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    mode: 'index',
                    callbacks: {
                        label: function (context) {
                            if (context.dataset.label === 'Durée (heures)') {
                                return `${context.dataset.label}: ${context.raw.toFixed(2)} h`;
                            }
                            return `${context.dataset.label}: ${context.raw}`;
                        }
                    }
                },
                legend: {
                    position: 'top',
                },
                title: {
                    display: true,
                    text: `Évolution ${periodeType === 'mois' ? 'mensuelle' : 'hebdomadaire'} des aléas`,
                    font: {
                        size: 16,
                        weight: 'bold'
                    },
                    padding: {
                        top: 10,
                        bottom: 20
                    }
                }
            },
            scales: {
                x: {
                    grid: {
                        display: false
                    }
                },
                count: {
                    type: 'linear',
                    position: 'left',
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Nombre d\'aléas'
                    }
                },
                duree: {
                    type: 'linear',
                    position: 'right',
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'Durée (heures)'
                    },
                    grid: {
                        display: false
                    }
                }
            }
        }
    });
}

/**
 * Réinitialiser la modale des aléas
 */
function resetAleasModal() {
    document.getElementById('aleas-operateur-name').textContent = '--';
    document.getElementById('aleas-table-body').innerHTML = '';
    document.getElementById('aleas-count').textContent = '0 aléa';
    document.getElementById('aleas-filters-info').textContent = '';
}

/**
 * Remplir le tableau des aléas
 * @param {Array} aleas - Liste des aléas à afficher
 */
function populateAleasTable(aleas) {
    const tbody = document.getElementById('aleas-table-body');
    tbody.innerHTML = '';

    aleas.forEach(function (alea) {
        const tr = document.createElement('tr');

        // Déterminer la classe pour le type d'aléa
        let typeBadgeClass = 'bg-secondary';
        switch (alea.typeAlea) {
            case 'Qualité':
                typeBadgeClass = 'bg-primary';
                break;
            case 'Prépa':
                typeBadgeClass = 'bg-info';
                break;
            case 'Maintenance':
                typeBadgeClass = 'bg-warning text-dark';
                break;
            case 'Formation':
                typeBadgeClass = 'bg-success';
                break;
            case 'Réunion':
                typeBadgeClass = 'bg-danger';
                break;
        }

        // Formater le commentaire (affecter une longueur maximale avec ellipsis)
        let commentaire = alea.commentaire || '';
        const commentaireComplet = commentaire;
        let commentaireAffiche = commentaire;

        if (commentaire.length > 50) {
            commentaireAffiche = commentaire.substring(0, 47) + '...';
        }

        tr.innerHTML = `
        <td>${alea.date}</td>
        <td><span class="badge ${typeBadgeClass}">${alea.typeAlea || 'Non spécifié'}</span></td>
        <td>${alea.poste || 'Non spécifié'}</td>
        <td>${alea.duree || '-'}</td>
        <td>${commentaireAffiche ? `<span title="${commentaireComplet}">${commentaireAffiche}</span>` : '-'}</td>
      `;

        tbody.appendChild(tr);
    });

    // Ajouter un gestionnaire d'événement pour exporter les aléas
    document.getElementById('btn-export-aleas').onclick = function () {
        exportAleasToCSV(aleas, document.getElementById('aleas-operateur-name').textContent);
    };
}

/**
 * Exporter les aléas vers un fichier CSV
 * @param {Array} aleas - Liste des aléas à exporter
 * @param {string} operateur - Nom de l'opérateur
 */
function exportAleasToCSV(aleas, operateur) {
    // Définir les en-têtes du CSV
    let csvContent = "Date,Type,Poste,Durée,Commentaire\n";

    // Ajouter chaque aléa
    aleas.forEach(function (alea) {
        // Échapper les virgules et les guillemets dans les champs
        const escapedComment = (alea.commentaire || '').replace(/"/g, '""');

        csvContent += `${alea.date},"${alea.typeAlea || 'Non spécifié'}","${alea.poste || 'Non spécifié'}",${alea.duree || ''},"${escapedComment}"\n`;
    });

    // Créer un élément de lien pour le téléchargement
    const encodedUri = encodeURI('data:text/csv;charset=utf-8,' + csvContent);
    const link = document.createElement('a');
    link.setAttribute('href', encodedUri);
    link.setAttribute('download', `aleas_${operateur.replace(/\s+/g, '_')}_${new Date().toISOString().slice(0, 10)}.csv`);

    // Simuler un clic sur le lien
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

function createOperateurEquipesChart() {
    if (!detailOperateur.statsEquipes || detailOperateur.statsEquipes.length === 0) return;

    const ctx = document.getElementById('chart-operateur-equipes').getContext('2d');

    // Détruire le graphique s'il existe déjà
    if (window.operateurEquipesChart) {
        window.operateurEquipesChart.destroy();
    }

    const labels = detailOperateur.statsEquipes.map(stat => stat.equipe);
    const data = detailOperateur.statsEquipes.map(stat => stat.rendement);
    const backgroundColor = CONFIG.colors.colors.slice(0, labels.length);

    // Créer le graphique
    window.operateurEquipesChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'Rendement par équipe',
                data: data,
                backgroundColor: backgroundColor,
                borderWidth: 0,
                borderRadius: 6,
                maxBarThickness: 50
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    callbacks: {
                        afterLabel: function (context) {
                            const stat = detailOperateur.statsEquipes[context.dataIndex];
                            return [`Nombre d'entrées: ${stat.nbEntrees}`];
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: {
                        callback: function (value) {
                            return value.toFixed(2);
                        }
                    }
                },
                x: {
                    grid: {
                        display: false
                    }
                }
            }
        }
    });
}

/**
 * Fonctions auxiliaires
 */
function populateFilterSelectors() {
    // Remplir le sélecteur d'équipes
    const equipeSelect = document.getElementById('equipe-select');
    equipeSelect.innerHTML = '<option value="">Toutes les équipes</option>';

    allData.equipes.forEach(equipe => {
        const option = document.createElement('option');
        option.value = equipe;
        option.textContent = equipe;
        equipeSelect.appendChild(option);
    });

    // Remplir le sélecteur de postes
    const posteSelect = document.getElementById('poste-select');
    posteSelect.innerHTML = '<option value="">Tous les postes</option>';

    allData.postes.forEach(poste => {
        const option = document.createElement('option');
        option.value = poste;
        option.textContent = poste;
        posteSelect.appendChild(option);
    });
}

function populateOperateurSelector() {
    if (allData && allData.operateurs) {
        const operateurs = allData.operateurs;
        populateOperateurSelectorWithData(operateurs);
    } else {
        console.warn("Données des opérateurs non disponibles");
    }
}

function filterOperateursTable() {
    const searchText = document.getElementById('operateur-search').value.toLowerCase();
    const rows = document.getElementById('table-operateurs').querySelectorAll('tbody tr');

    let found = false;

    rows.forEach(row => {
        const operateur = row.querySelector('td:nth-child(2)').textContent.toLowerCase();
        if (operateur.includes(searchText)) {
            row.style.display = '';
            found = true;
        } else {
            row.style.display = 'none';
        }
    });

    // Afficher un message si aucun résultat
    const tableBody = document.getElementById('table-operateurs').querySelector('tbody');
    const noResultRow = tableBody.querySelector('.no-result-row');

    if (!found && searchText.length > 0) {
        if (!noResultRow) {
            const tr = document.createElement('tr');
            tr.className = 'no-result-row';
            tr.innerHTML = `
              <td colspan="7" class="text-center py-3">
                <i class="fas fa-search me-2"></i>
                Aucun opérateur trouvé pour "${searchText}"
              </td>
            `;
            tableBody.appendChild(tr);
        } else {
            noResultRow.style.display = '';
        }
    } else if (noResultRow) {
        noResultRow.style.display = 'none';
    }
}

function clearOperateurSearch() {
    document.getElementById('operateur-search').value = '';
    filterOperateursTable();
}

function handleError(error) {
    console.error("Erreur:", error);
    document.getElementById('loader').style.display = 'none';
    alert("Une erreur s'est produite: " + error);
}
</script>

</body>
</html>
                  
